{
    "HLD": {
        "prefix": "HLD",
        "body": [
            "#define func max",
            "",
            "vvi parent;",
            "vi depth, label, toc, subsize, seg, vals;",
            "int mxN = 20;",
            "",
            "void dfsone(int src, int par, vi *adj, int dep=0){",
            "    depth[src] = dep;",
            "    parent[src][0] = par;",
            "    subsize[src] = 1;",
            "    for(int i=1;i<mxN;i++){",
            "        parent[src][i] = parent[parent[src][i-1]][i-1];",
            "    }",
            "    for(auto i:adj[src]){",
            "        if(i == par) continue;",
            "        dfsone(i,src,adj,dep+1);",
            "        subsize[src] += subsize[i];",
            "    }",
            "}",
            "",
            "int timer = 0;",
            "",
            "void dfstwo(int src, int parent, vi *adj, bool heavy){",
            "    label[src] = timer++;",
            "    toc[src] = ((heavy)?toc[parent]:src);",
            "    int mx=0,pos=-1;",
            "    for(auto i:adj[src]) {",
            "        if(i == parent) continue;",
            "        if(subsize[i] > mx){",
            "            mx = subsize[i];",
            "            pos = i;",
            "        }",
            "    }",
            "    if(pos != -1)dfstwo(pos,src,adj,1);",
            "    for(auto i:adj[src]) {",
            "        if(i == parent) continue;",
            "        if(i == pos) continue;",
            "        else {",
            "            dfstwo(i,src,adj,0);",
            "        }",
            "    }",
            "}",
            "",
            "void update(int pos, int val, int st, int en, int ind, vi &seg)",
            "{",
            "    if(pos > en or pos < st) return;",
            "    else if(st==en){",
            "        seg[ind] = val;",
            "    }",
            "    else{",
            "        update(pos,val,left);",
            "        update(pos,val,right);",
            "        seg[ind] = func(seg[ridx], seg[lidx]);",
            "    }",
            "}",
            "",
            "int getans(int l, int r, int st, int en, int ind, vi &seg)",
            "{",
            "    if(l > r) swap(l,r);",
            "    if(r < st or l > en) return intmin;",
            "    else if(r >= en and l <= st) return seg[ind];",
            "    else{",
            "        if(st==en) return seg[ind];",
            "        auto a = getans(l,r,left);",
            "        auto b = getans(l,r,right);",
            "        auto c = func(a,b);",
            "        return c;",
            "    }",
            "}",
            "",
            "",
            "auto lca = [](int u, int v){",
            "    if(depth[u] < depth[v]) swap(u,v);",
            "    drep(i,mxN-1,0) if(depth[u]-(1<<i) >= depth[v]) u = parent[u][i];",
            "    if(u == v) return v;",
            "    drep(i,mxN-1,0) {",
            "        if(parent[u][i] != parent[v][i]){",
            "            u = parent[u][i];",
            "            v = parent[v][i];",
            "        }",
            "    }",
            "    return parent[u][0];",
            "};",
            "",
            "void solve()",
            "{",
            "    int n, q;",
            "    cin >> n >> q;",
            "    vi adj[n+1];",
            "    vals.resize(n+1);",
            "    rep(i,1,n+1) cin >> vals[i];",
            "    makegraph(adj,n-1);",
            "    parent.assign(n+1, vi(mxN, 0));",
            "    depth.resize(n+1);",
            "    label.resize(n+1);",
            "    toc.resize(n+1);",
            "    subsize.resize(n+1);",
            "    seg.resize(4*n);",
            "    dfsone(1,0,adj);",
            "    dfstwo(1,0,adj,false);",
            "    trace(label);trace(vals);trace(depth);trace(subsize);",
            "    rep(i,1,n+1) {",
            "        update(label[i],vals[i],0,n-1,0,seg);",
            "    }",
            "    while(q--) {",
            "        newint(type,x,y);",
            "        if(type == 1) {",
            "            update(label[x],y,0,n-1,0,seg);",
            "            vals[x] = y;",
            "        } else {",
            "            int l = lca(x,y);",
            "            trace(x,y,l);",
            "            int ans1 = vals[x], ans2 = vals[y];",
            "            int node1 = x, node2 = y;",
            "            while(node1 != l) {",
            "                if(toc[node1] == node1) {",
            "                    node1 = parent[node1][0];",
            "                    ans1 = func(ans1, vals[node1]);",
            "                }",
            "                else if(depth[toc[node1]] >= depth[l]) {",
            "                    ans1 = func(ans1, getans(label[toc[node1]],label[node1],0,n-1,0,seg));",
            "                    node1 = toc[node1];",
            "                } else {",
            "                    ans1 = func(ans1, getans(label[l], label[node1], 0, n-1, 0, seg));",
            "                    node1 = l;",
            "                }",
            "            }",
            "            while(node2 != l) {",
            "                if(toc[node2] == node2) {",
            "                    node2 = parent[node2][0];",
            "                    ans2 = func(ans2, vals[node2]);",
            "                }",
            "                else if(depth[toc[node2]] >= depth[l]) {",
            "                    ans2 = func(ans2, getans(label[toc[node2]],label[node2],0,n-1,0,seg));",
            "                    node2 = toc[node2];",
            "                } else {",
            "                    ans2 = func(ans2, getans(label[l], label[node2],0,n-1,0,seg));",
            "                    node2 = l;",
            "                }",
            "            }",
            "            cout << func(ans1,ans2) << endl;",
            "        }",
            "    }",
            "    cout << endl;",
            "}"
        ],
        "description": "HLD"
    }
}