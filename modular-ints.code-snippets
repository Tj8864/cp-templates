{
    "modular integers": {
        "prefix": "modular",
        "body": [
            "long long binExpp(long long a,long long b,long long modulo)",
            "{",
            "    long long prod = a;",
            "    long long ans = 1;",
            "    while(b){",
            "        if(b%2) ans = (ans*prod)%modulo;",
            "        b /= 2;",
            "        prod = (prod*prod)%modulo;",
            "    }",
            "    return ans;",
            "}",
            "",
            "template<const int mod>",
            "class Mint{",
            "    long long val;",
            "",
            "    public: ",
            "    Mint(long long _val){",
            "        val = (_val%mod+mod)%mod;",
            "    }",
            "    Mint(){",
            "        val = 0;",
            "    }",
            "    Mint operator+(Mint b){",
            "        return Mint((this->val+b.val)%mod);",
            "    }",
            "    Mint operator-(Mint b){",
            "        return Mint(this->val-b.val+mod)%mod;",
            "    }",
            "    Mint operator*(Mint b){",
            "        return Mint((this->val*b.val)%mod);",
            "    }",
            "    Mint operator/(Mint b){",
            "        return (Mint(binExpp(b(), mod-2, mod))*(*this));",
            "    }",
            "    long long &operator()(){",
            "        return val;",
            "    }",
            "    Mint operator+=(Mint b){",
            "        return *this = *this+b;",
            "    }",
            "    Mint operator-=(Mint b){",
            "        return *this = *this-b;",
            "    }",
            "    Mint operator*=(Mint b){",
            "        return *this = *this*b;",
            "    }",
            "    Mint operator/=(Mint b){",
            "        return *this = *this/b;",
            "    }",
            "    int operator%(int modulo){",
            "        return val%modulo;",
            "    }",
            "    int operator%(Mint modulo){",
            "        return val%(modulo());",
            "    }",
            "    Mint operator++(){",
            "        return *this = *this+Mint(1);",
            "    }",
            "    Mint operator= (int x){",
            "        return (*this).val = (x%mod+mod)%mod;",
            "    }",
            "    Mint operator^(Mint pow){",
            "        return Mint(binExpp((*this)(),pow(),mod));",
            "    }",
            "};",
            "template<const int mod>",
            "istream &operator>>(istream &in, Mint<mod> &a)",
            "{",
            "    return in >> a();",
            "}",
            "template<const int mod>",
            "ostream &operator<<(ostream &outt, Mint<mod> a)",
            "{",
            "    return outt<<a();",
            "}",
            "template<const int mod>",
            "Mint<mod> operator+(int mul, Mint<mod> m){",
            "    return m+mul;",
            "}",
            "template<const int mod>",
            "Mint<mod> operator*(int mul, Mint<mod> m){",
            "    return m*Mint<mod>(mul);",
            "}",
            "template<const int mod>",
            "vector<Mint<mod>> Factorial(int n)",
            "{",
            "    vector<Mint<mod>> fact(n+1);",
            "    fact[0] = 1;",
            "    for(int i=1;i<=n;i++) fact[i] = i*fact[i-1];",
            "    return fact;",
            "}",
            "",
            "using mint = Mint<1000000007>;",
            "using mint2 = Mint<998244353>;",
            "using vmi = vector<mint>;"
        ],
        "description": "modular"
    }
}