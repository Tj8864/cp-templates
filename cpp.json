{
    "boilerplate": {
        "prefix": "boilerplate",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "//#pragma GCC target (\"avx2\")",
            "//#pragma GCC optimize (\"O3\")",
            "//#pragma GCC optimize (\"unroll-loops\")",
            "",
            "// #include<bits/extc++.h>",
            "// using namespace __gnu_pbds;",
            "// template<typename T>",
            "// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "// template<typename T>",
            "// using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "// #define ook order_of_key",
            "// #define fbo find_by_order",
            "",
            "#ifndef ONLINE_JUDGE",
            "#define debug(x) cerr << #x << \" = \" << x << endl",
            "#define dbg(x)                \\",
            "    {                         \\",
            "        cerr << #x << \" = {\"; \\",
            "        int cnt = x.size();   \\",
            "        for (auto i : x)      \\",
            "        {                     \\",
            "            cerr << i;        \\",
            "            cnt--;            \\",
            "            if (cnt)          \\",
            "                cerr << \", \"; \\",
            "        }                     \\",
            "        cerr << \"}\"<< endl;   \\",
            "    }",
            "#else",
            "#define debug(x) 1",
            "#define dbg(x) 1",
            "#endif",
            "#define makegraph(adj, num)       \\",
            "    for (int i = 0; i < num; i++) \\",
            "    {                             \\",
            "        int u, v;                 \\",
            "        cin >> u >> v;            \\",
            "        adj[u].push_back(v);      \\",
            "        adj[v].push_back(u);      \\",
            "    }",
            "#define rep(i, k, n) for (int i = k; i < n; i++)",
            "#define rept(i, k, n) for (auto i = k; i != n; ++i)",
            "#define drep(i, k, n) for (int i = k; i >= n; i--)",
            "#define pb push_back",
            "#define mp make_pair",
            "#define ub upper_bound",
            "#define lb lower_bound",
            "#define all(a) a.begin(), a.end()",
            "#define endl '\\n'",
            "#define ld long double",
            "#define ll long long",
            "#define clr(s) memset(s, 0, sizeof(s))",
            "#define valset(arr, size, val) rep(i, 0, size) arr[i] = val;",
            "#define newint(...) int __VA_ARGS__;read(__VA_ARGS__);",
            "#define setbits(x) __builtin_popcount(x)",
            "#define setbitsll(x) __builtin_popcountll(x)",
            "#define Tj return",
            "#define out 0",
            "// #define segtree",
            "#ifdef segtree",
            "#define mid (st + en) / 2",
            "#define lidx 2 * ind + 1",
            "#define ridx 2 * ind + 2",
            "#define left st, mid, lidx, seg",
            "#define right mid + 1, en, ridx, seg",
            "#endif",
            "typedef vector<int> vi;",
            "typedef vector<pair<int, int>> vii;",
            "typedef pair<int, int> ii;",
            "typedef pair<int, pair<int, int>> iii;",
            "typedef map<int, int> mii;",
            "typedef map<char, int> mci;",
            "typedef set<int> si;",
            "typedef vector<vector<int>> vvi;",
            "const int intmax = 2147483647;",
            "const int intmin = -2147483648;",
            "const int mod = 1000000007;",
            "const int mod2 = 998244353;",
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "",
            "template <typename T>istream &operator>>(istream &in, vector<T> &v){for (auto &i : v)in >> i;return in;}",
            "template <typename T>ostream &operator<<(ostream &ost, vector<T> v){if(&ost == &cerr){cerr <<\"{\";int cnt = v.size();for(auto x:v){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:v)ost << i << \" \";return ost;}",
            "template <typename U, typename V>istream &operator>>(istream &in, pair<U, V> &p){in>>p.first>>p.second;return in;}",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, pair<U, V> p){if (&ost == &cerr)ost << \"{\" << p.first << \": \" << p.second << \"}\";else ost << p.first << \" \" << p.second << \" \";return ost;}",
            "template <typename... T>void read(T &...args){((cin >> args), ...);}",
            "template <typename... T>void print(T... args){((cout << args << \" \"), ...);cout << endl;}",
            "",
            "void solve()",
            "{",
            "    $0",
            "}",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    int t;",
            "    cin >> t;",
            "    rep(var,0,t)",
            "        solve();",
            "    Tj out;",
            "}"
        ],
        "description": "boilerplate"
    },
    "spf": {
        "prefix": "spf",
        "body": [
            "rep(i,0,${0:200001}) spf[i] = i;",
            "for(int i=2;i*i<${0:200001};i++){",
            "    if(spf[i] == i){",
            "        for(int j=i*i;j<${0:200001};j+=i){",
            "            if(spf[j]==j) spf[j] = i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "spf"
    },
    "binexp": {
        "prefix": "binexp",
        "body": [
            "long long binExp(long long a,long long b,long long modulo)",
            "{",
            "    long long prod = a;",
            "    long long ans = 1;",
            "    while(b){",
            "        if(b%2) ans = (ans*prod)%modulo;",
            "        b /= 2;",
            "        prod = (prod*prod)%modulo;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "binexp"
    },
    "Lowest Common Ancestor": {
        "prefix": "lca",
        "body": [
            "vvi parent;",
            "vi depth;",
            "int mxN;",
            "",
            "void dfs(int src, int par, vi *adj, int dep=0){",
            "    depth[src] = dep;",
            "    parent[src][0] = par;",
            "    for(int i=1;i<mxN;i++){",
            "        parent[src][i] = parent[parent[src][i-1]][i-1];",
            "    }",
            "    for(auto i:adj[src]){",
            "        if(i == par) continue;",
            "        dfs(i,src,adj,dep+1);",
            "    }",
            "}",
            "",
            "auto lca = [](int u, int v){",
            "    if(depth[u] < depth[v]) swap(u,v);",
            "    drep(i,mxN,0) if(depth[u]-(1<<i) >= depth[v]) u = parent[u][i];",
            "    if(u == v) return v;",
            "    drep(i,mxN-1,0) {",
            "        if(parent[u][i] != parent[v][i]){",
            "            u = parent[u][i];",
            "            v = parent[v][i];",
            "        }",
            "    }",
            "    return parent[u][0];",
            "};"
        ],
        "description": "lca"
    },
    "segmenttree": {
        "prefix": "segment",
        "body": [
            "void maketree($1 *arr, int st, int en, int ind , $2 *seg)",
            "{",
            "    if(st==en) seg[ind] = arr[st];",
            "    else{",
            "        maketree(arr,left);",
            "        maketree(arr,right);",
            "        seg[ind] = $3",
            "    }",
            "}",
            "",
            "void update($4, int st, int en, int ind, $2 *seg)",
            "{",
            "    if($6) return;",
            "    else if(st==en){",
            "        seg[ind] = $7",
            "    }",
            "    else{",
            "        update($5,left);",
            "        update($5,right);",
            "        seg[ind] = $3",
            "    }",
            "}",
            "",
            "$8 getans(int l, int r, int st, int en, int ind, $2 *seg)",
            "{",
            "    if(r < st or l > en) return $9;",
            "    else if(r >= en and l <= st) return seg[ind];",
            "    else{",
            "        if(st==en) return seg[ind];",
            "        auto a = getans(l,r,left);",
            "        auto b = getans(l,r,right);",
            "        auto c = $10",
            "        return c;",
            "    }",
            "}",
            ""
        ],
        "description": "SEgment tree'"
    },
    "Mo's algo": {
        "prefix": "sqrtdecomp",
        "body": [
            "struct query{",
            "    ii range;",
            "    int order;",
            "    query(){}",
            "};",
            "",
            "",
            "void solve()",
            "{",
            "    int n,q;",
            "    cin >> n >> q;",
            "    vi v(n);",
            "    cin >> v;",
            "    int blocksize = 0;",
            "    while(blocksize*blocksize <= n) blocksize++;",
            "    blocksize--;",
            "    vector<query> qs(q);",
            "    rep(i,0,q) cin >> qs[i].range,qs[i].range.first--,qs[i].range.second--, qs[i].order = i;",
            "    sort(all(qs),[&blocksize](query a, query b){",
            "        if(a.range.first/blocksize == b.range.first/blocksize) return a.range.second < b.range.second;",
            "        return a.range.first/blocksize < b.range.first/blocksize;",
            "    });",
            "    int l=qs[0].range.first, r=qs[0].range.first;",
            "    int ans;",
            "    vi answers(q);",
            "    rep(i,0,q){",
            "        if(i == 0 or qs[i].range.first/blocksize != qs[i-1].range.first/blocksize){",
            "            l = r = qs[i].range.first;",
            "        }",
            "        while(r < qs[i].range.second){",
            "            r++;",
            "        }",
            "        if(l < qs[i].range.first){",
            "            while(l != qs[i].range.first){",
            "                l++;",
            "            }",
            "        }",
            "        else if(l > qs[i].range.first){",
            "            while(l != qs[i].range.first){",
            "                l--;",
            "            }",
            "        }",
            "        answers[qs[i].order] = ans;",
            "    }",
            "    for(auto i:answers) cout << i << endl;",
            "}"
        ],
        "description": "Mo's algo "
    },
    "Basic trie": {
        "prefix": "basictrie",
        "body": [
            "struct trieNode{",
            "    char ch;",
            "    int ending;",
            "    map<char, trieNode*> pointers;",
            "    trieNode* parent;",
            "    trieNode(){",
            "        ch = '\\0';",
            "        ending = 0;",
            "        pointers.clear();",
            "        parent = nullptr;",
            "    }",
            "};",
            "",
            "class trie{",
            "    public:",
            "    trieNode *root;",
            "    trie()",
            "    {",
            "        root = new trieNode;",
            "        root->ending = 0;",
            "        root->ch = '\\0';",
            "        root->parent = nullptr;",
            "    }",
            "    int count(string s){",
            "        trieNode *ptr = root;",
            "        int p = 0;",
            "        while(p < s.size() and ptr->pointers.find(s[p])!=ptr->pointers.end()){",
            "            ptr = ptr->pointers[s[p]];",
            "            p++;",
            "        }",
            "        if(p < s.size()) return 0;",
            "        else return ptr->ending;",
            "    }",
            "    void insert(string s){",
            "        trieNode *ptr = root;",
            "        for(int i=0;i<s.size();i++){",
            "            if(ptr->pointers.find(s[i]) == ptr->pointers.end())",
            "                ptr->pointers[s[i]] = new trieNode,",
            "                ptr->pointers[s[i]]->ch = s[i];",
            "                ptr->pointers[s[i]]->parent = ptr;",
            "                ptr = ptr->pointers[s[i]];",
            "        }",
            "        ptr->ending++;",
            "    }",
            "",
            "    void remove(string s){",
            "        if(count(s) == 0) return;",
            "        trieNode *ptr = root;",
            "        for(char c:s){",
            "            ptr = ptr->pointers[c];",
            "        }",
            "        ptr->ending--;",
            "        while(ptr->parent != nullptr){",
            "            char c;",
            "            if(ptr->pointers.empty() and ptr->ending == 0){",
            "                c = ptr->ch;",
            "                ptr = ptr->parent;",
            "                delete ptr->pointers[c];",
            "                ptr->pointers[c] = nullptr;",
            "                ptr->pointers.erase(c);",
            "            }",
            "            else break;",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "Basic implementation of Trie"
    },
    "modular integers": {
        "prefix": "modular",
        "body": [
            "long long binExpp(long long a,long long b,long long modulo)",
            "{",
            "    long long prod = a;",
            "    long long ans = 1;",
            "    while(b){",
            "        if(b%2) ans = (ans*prod)%modulo;",
            "        b /= 2;",
            "        prod = (prod*prod)%modulo;",
            "    }",
            "    return ans;",
            "}",
            "",
            "template<const int mod>",
            "class Mint{",
            "    long long val;",
            "",
            "    public: ",
            "    Mint(long long _val){",
            "        val = (_val%mod+mod)%mod;",
            "    }",
            "    Mint(){",
            "        val = 0;",
            "    }",
            "    Mint operator+(Mint b){",
            "        return Mint((this->val+b.val)%mod);",
            "    }",
            "    Mint operator-(Mint b){",
            "        return Mint(this->val-b.val+mod)%mod;",
            "    }",
            "    Mint operator*(Mint b){",
            "        return Mint((this->val*b.val)%mod);",
            "    }",
            "    Mint operator/(Mint b){",
            "        return (Mint(binExpp(b(), mod-2, mod))*(*this));",
            "    }",
            "    long long &operator()(){",
            "        return val;",
            "    }",
            "    Mint operator+=(Mint b){",
            "        return *this = *this+b;",
            "    }",
            "    Mint operator-=(Mint b){",
            "        return *this = *this-b;",
            "    }",
            "    Mint operator*=(Mint b){",
            "        return *this = *this*b;",
            "    }",
            "    Mint operator/=(Mint b){",
            "        return *this = *this/b;",
            "    }",
            "    int operator%(int modulo){",
            "        return val%modulo;",
            "    }",
            "    int operator%(Mint modulo){",
            "        return val%(modulo());",
            "    }",
            "    Mint operator++(){",
            "        return *this = *this+Mint(1);",
            "    }",
            "    Mint operator= (int x){",
            "        return (*this).val = (x%mod+mod)%mod;",
            "    }",
            "    Mint operator^(Mint pow){",
            "        return Mint(binExpp((*this)(),pow(),mod));",
            "    }",
            "};",
            "template<const int mod>",
            "istream &operator>>(istream &in, Mint<mod> &a)",
            "{",
            "    return in >> a();",
            "}",
            "template<const int mod>",
            "ostream &operator<<(ostream &outt, Mint<mod> a)",
            "{",
            "    return outt<<a();",
            "}",
            "template<const int mod>",
            "Mint<mod> operator+(int mul, Mint<mod> m){",
            "    return m+mul;",
            "}",
            "template<const int mod>",
            "Mint<mod> operator*(int mul, Mint<mod> m){",
            "    return m*Mint<mod>(mul);",
            "}",
            "template<const int mod>",
            "vector<Mint<mod>> Factorial(int n)",
            "{",
            "    vector<Mint<mod>> fact(n+1);",
            "    fact[0] = 1;",
            "    for(int i=1;i<=n;i++) fact[i] = i*fact[i-1];",
            "    return fact;",
            "}",
            "",
            "using mint = Mint<1000000007>;",
            "using mint2 = Mint<998244353>;",
            "using vmi = vector<mint>;"
        ],
        "description": "modular"
    },
    "randomstuff": {
        "prefix": "randomstuff",
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "",
            "inline int randomIndex(int maxInd) {",
            "    return abs(int(rng()))%maxInd; ",
            "}",
            "",
            "inline int random(int from, int to){",
            "    if(to == from) return to;",
            "    return (abs(int(rng()))%(to-from))+from;",
            "}",
            "",
            "template<typename T>",
            "inline void randomShuffle(vector<T> &v){",
            "    for(int i=0;i<v.size();i++){",
            "        int j = randomIndex(i+1);",
            "        swap(v[j],v[i]);",
            "    }",
            "}",
            "",
            "template<typename T>",
            "inline void randomShuffle(T *arr, int sz){",
            "    for(int i=0;i<sz;i++){",
            "        int j = randomIndex(i+1);",
            "        swap(arr[j],arr[i]);",
            "    }",
            "}"
        ],
        "description": "randomstuff"
    },
    "hashing": {
        "prefix": "hashing",
        "body": [
            "constexpr int largeprimes[] = {1000000007,1000000009,1000000021,1000000033,1000000087,1000000093,1000000097,1000000103,1000000123,1000000181,1000000207,1000000223,1000000241};",
            "template<const int mod1, const int mod2, const int base = 31>",
            "struct Hash{",
            "    private:",
            "    long long baseInverse1, baseInverse2;",
            "    long long lenPow1, lenPow2;",
            "    public:",
            "    long long hash1, hash2;",
            "    int length;",
            "    Hash(string s){",
            "        baseInverse1 = binPow(base,mod1-2,mod1);",
            "        baseInverse2 = binPow(base,mod2-2,mod2);",
            "        hash1 = hash2 = length = 0;",
            "        for(auto i:s){",
            "            hash1 *= (base);",
            "            hash2 *= (base);",
            "            hash1 += (i-'a'+1);",
            "            hash2 += (i-'a'+1);",
            "            hash1 %= mod1;",
            "            hash2 %= mod2;",
            "            length++;",
            "        }",
            "        lenPow1 = binPow(base,length,mod1);",
            "        lenPow2 = binPow(base,length,mod2);",
            "    }",
            "    Hash(){",
            "        baseInverse1 = binPow(base,mod1-2,mod1);",
            "        baseInverse2 = binPow(base,mod2-2,mod2);",
            "        lenPow1 = lenPow2 = 1;",
            "        hash1 = hash2 = length = 0;",
            "    }",
            "    bool operator==(const Hash h){",
            "        return (this->hash1==h.hash1 and this->hash2==h.hash2 and this->length == h.length);",
            "    }",
            "    void push_back(char c){",
            "        hash1 *= (base);",
            "        hash2 *= (base);",
            "        hash1 += (c-'a'+1);",
            "        hash2 += (c-'a'+1);",
            "        hash1 %= mod1;",
            "        hash2 %= mod2;",
            "        lenPow1 = (lenPow1*base)%mod1;",
            "        lenPow2 = (lenPow2*base)%mod2;",
            "        length++;",
            "    }",
            "    void push_front(char c){",
            "        hash1 += (c-'a'+1)*lenPow1;",
            "        hash1 %= mod1;",
            "        hash2 += (c-'a'+1)*lenPow2;",
            "        hash2 %= mod2;",
            "        lenPow1 = (lenPow1*base)%mod1;",
            "        lenPow2 = (lenPow2*base)%mod2;",
            "        length++;",
            "    }",
            "    void pop_back(char c){",
            "        hash1 -= (c-'a'+1);",
            "        hash1 *= baseInverse1;",
            "        hash1 %= mod1;",
            "        hash2 -= (c-'a'+1);",
            "        hash2 *= baseInverse2;",
            "        hash2 %= mod2;",
            "        lenPow1 = (lenPow1*baseInverse1)%mod1;",
            "        lenPow2 = (lenPow2*baseInverse2)%mod2;",
            "        length--;",
            "    }",
            "    void pop_front(char c){",
            "        lenPow1 = (lenPow1*baseInverse1)%mod1;",
            "        lenPow2 = (lenPow2*baseInverse2)%mod2;",
            "        hash1 -= ((c-'a'+1)*lenPow1)%mod1;",
            "        hash1 %= mod1;",
            "        hash1 += mod1;",
            "        hash1 %= mod1;",
            "        hash2 -= ((c-'a'+1)*lenPow2)%mod2;",
            "        hash2 %= mod2;",
            "        hash2 += mod2;",
            "        hash2 %= mod2;",
            "        length--;",
            "    }",
            "};",
            "",
            "template<const int m1, const int m2>",
            "ostream &operator<<(ostream &ost, Hash<m1,m2> h){",
            "    ost << \"{\" << h.hash1 << \", \" << h.hash2 << \"}\\n\";",
            "    return ost;",
            "}",
            "",
            "template<const int m1, const int m2>",
            "bool operator<(Hash<m1,m2> h1, Hash<m1,m2> h2){",
            "    return make_pair(h1.hash1, make_pair(h1.hash2,h1.length)) < make_pair(h2.hash1, make_pair(h2.hash2,h2.length));",
            "}",
            ""
        ],
        "description": "hashing"
    }
}