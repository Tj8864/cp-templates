{
    "boilerplate": {
        "prefix": "boilerplate",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "//#pragma GCC target (\"avx2\")",
            "//#pragma GCC optimize (\"O3\")",
            "//#pragma GCC optimize (\"unroll-loops\")",
            "",
            "// #include<bits/extc++.h>",
            "// using namespace __gnu_pbds;",
            "// template<typename T>",
            "// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "// template<typename T>",
            "// using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "// #define ook order_of_key",
            "// #define fbo find_by_order",
            "",
            "#define GREEN \"\\033[1;32m\"",
            "#define YELLOW \"\\033[1;33m\"",
            "#define ORANGE \"\\033[1;34m\"",
            "#define PURPLE \"\\033[1;35m\"",
            "#define BLUE \"\\033[1;36m\"",
            "#ifndef ONLINE_JUDGE",
            "#define trace(...) __f(YELLOW,#__VA_ARGS__, __VA_ARGS__)",
            "#define Trace(color,...) __f(color,#__VA_ARGS__, __VA_ARGS__)",
            "template <typename Arg1>",
            "    void __f(const char *color, const char* name, Arg1&& arg1){",
            "        cerr << color << name << \": \\033[0;37m\" << arg1 << \"\\033[0m \" << endl;",
            "    }",
            "    template <typename Arg1, typename... Args>",
            "    void __f(const char *color, const char* names, Arg1&& arg1, Args&&... args){",
            "        const char* comma = strchr(names + 1, ',');",
            "        cerr << color;",
            "        cerr.write(names, comma - names) << \": \\033[0;37m\" << arg1 << \"\\033[0m \" << endl;",
            "        __f(color, comma+1, args...);",
            "    }",
            "#define wait(x) this_thread::sleep_for(chrono::milliseconds(x))",
            "#define seed 127",
            "#else",
            "#define trace(...) 42",
            "#define Trace(...) 167",
            "#define seed chrono::steady_clock::now().time_since_epoch().count()",
            "#define wait(x) 137",
            "#endif",
            "#define makegraph(adj, num)       \\",
            "    for (int i = 0; i < num; i++) \\",
            "    {                             \\",
            "        int u, v;                 \\",
            "        cin >> u >> v;            \\",
            "        adj[u].push_back(v);      \\",
            "        adj[v].push_back(u);      \\",
            "    }",
            "#define rep(i, k, n) for (int i = k; i < n; i++)",
            "#define rept(i, k, n) for (auto i = k; i != n; ++i)",
            "#define drep(i, k, n) for (int i = k; i >= n; i--)",
            "#define repeat(n) for(int _=0;_<n;_++)",
            "#define pb push_back",
            "#define mp make_pair",
            "#define ub upper_bound",
            "#define lb lower_bound",
            "#define all(a) a.begin(), a.end()",
            "#define endl '\\n'",
            "#define ld long double",
            "#define ll long long",
            "#define clr(s) memset(s, 0, sizeof(s))",
            "#define valset(arr, size, val) rep(i, 0, size) arr[i] = val;",
            "#define newint(...) int __VA_ARGS__;read(__VA_ARGS__);",
            "#define setbits(x) __builtin_popcount(x)",
            "#define setbitsll(x) __builtin_popcountll(x)",
            "#define Tj return",
            "#define out 0",
            "// #define segtree",
            "#ifdef segtree",
            "#define mid (st + en) / 2",
            "#define lidx 2 * ind + 1",
            "#define ridx 2 * ind + 2",
            "#define left st, mid, lidx, seg",
            "#define right mid + 1, en, ridx, seg",
            "#endif",
            "typedef vector<int> vi;",
            "typedef vector<pair<int, int>> vii;",
            "typedef pair<int, int> ii;",
            "typedef pair<int, pair<int, int>> iii;",
            "typedef map<int, int> mii;",
            "typedef map<char, int> mci;",
            "typedef set<int> si;",
            "typedef vector<vector<int>> vvi;",
            "typedef __int128_t xll;",
            "const int intmax = 2147483647;",
            "const int intmin = -2147483648;",
            "const int mod = 1000000007;",
            "const int mod2 = 998244353;",
            "mt19937 rng(seed);",
            "",
            "//IO operators for vectors, pairs, sets, maps and __int128",
            "template <typename T>istream &operator>>(istream &in, vector<T> &v){for (auto &i : v)in >> i;return in;}",
            "template <typename T>ostream &operator<<(ostream &ost, vector<T> v){if(&ost == &cerr){cerr <<\"{\";int cnt = v.size();for(auto x:v){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:v)ost << i << \" \";return ost;}",
            "template <typename T>ostream &operator<<(ostream &ost, set<T> s){if(&ost == &cerr){cerr <<\"{\";int cnt = s.size();for(auto x:s){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:s)ost << i << \" \";return ost;}",
            "template <typename T>ostream &operator<<(ostream &ost, multiset<T> s){if(&ost == &cerr){cerr <<\"{\";int cnt = s.size();for(auto x:s){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:s)ost << i << \" \";return ost;}",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, map<U,V> &m){if(&ost == &cerr){cerr <<\"{\";int cnt = m.size();for(auto x:m){cerr << x; cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:m)ost << i;return ost;}",
            "template <typename U, typename V>istream &operator>>(istream &in, pair<U, V> &p){in>>p.first>>p.second;return in;}",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, pair<U, V> p){if (&ost == &cerr)ost << \"{\" << p.first << \": \" << p.second << \"}\";else ost << p.first << \" \" << p.second << \" \";return ost;}",
            "ostream &operator<<(ostream &ost, __int128_t x){string output = \"\";while(x)output += '0'+x%10, x /= 10;reverse(all(output)); ost << output;  return ost;}",
            "istream &operator>>(istream &in, __int128_t &x){x=0;string num;cin >> num;for(char c:num) x *= 10, x += c-'0';return in;}",
            "//Variadic IO",
            "template <typename... T>void read(T &...args){((cin >> args), ...);}",
            "template <typename... T>void print(T... args){((cout << args << \" \"), ...);cout << endl;}",
            "",
            "void solve()",
            "{",
            "    $0",
            "}",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    int t=1;",
            "    cin >> t;",
            "    rep(var,1,t+1)",
            "        // cout << \"Case #\" << var << \": \",",
            "        solve();",
            "    Tj out;",
            "}"
        ],
        "description": "boilerplate"
    },
    "spf": {
        "prefix": "spf",
        "body": [
            "rep(i,0,${0:200001}) spf[i] = i;",
            "for(int i=2;i*i<${0:200001};i++){",
            "    if(spf[i] == i){",
            "        for(int j=i*i;j<${0:200001};j+=i){",
            "            if(spf[j]==j) spf[j] = i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "spf"
    },
    "binexp": {
        "prefix": "binexp",
        "body": [
            "long long binPow(long long a,long long b,long long modulo)",
            "{",
            "    long long prod = a;",
            "    long long ans = 1;",
            "    while(b){",
            "        if(b%2) ans = (ans*prod)%modulo;",
            "        b /= 2;",
            "        prod = (prod*prod)%modulo;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "binexp"
    },
    "Lowest Common Ancestor": {
        "prefix": "lca",
        "body": [
            "vvi parent;",
            "vi depth;",
            "int mxN;",
            "",
            "void dfs(int src, int par, vi *adj, int dep=0){",
            "    depth[src] = dep;",
            "    parent[src][0] = par;",
            "    for(int i=1;i<mxN;i++){",
            "        parent[src][i] = parent[parent[src][i-1]][i-1];",
            "    }",
            "    for(auto i:adj[src]){",
            "        if(i == par) continue;",
            "        dfs(i,src,adj,dep+1);",
            "    }",
            "}",
            "",
            "auto lca = [](int u, int v){",
            "    if(depth[u] < depth[v]) swap(u,v);",
            "    drep(i,mxN-1,0) if(depth[u]-(1<<i) >= depth[v]) u = parent[u][i];",
            "    if(u == v) return v;",
            "    drep(i,mxN-1,0) {",
            "        if(parent[u][i] != parent[v][i]){",
            "            u = parent[u][i];",
            "            v = parent[v][i];",
            "        }",
            "    }",
            "    return parent[u][0];",
            "};"
        ],
        "description": "lca"
    },
    "segmenttree": {
        "prefix": "segment",
        "body": [
            "void maketree($1 *arr, int st, int en, int ind , $2 *seg)",
            "{",
            "    if(st==en) seg[ind] = arr[st];",
            "    else{",
            "        maketree(arr,left);",
            "        maketree(arr,right);",
            "        seg[ind] = $3",
            "    }",
            "}",
            "",
            "void update($4, int st, int en, int ind, $2 *seg)",
            "{",
            "    if($6) return;",
            "    else if(st==en){",
            "        seg[ind] = $7",
            "    }",
            "    else{",
            "        update($5,left);",
            "        update($5,right);",
            "        seg[ind] = $3",
            "    }",
            "}",
            "",
            "$8 getans(int l, int r, int st, int en, int ind, $2 *seg)",
            "{",
            "    if(r < st or l > en) return $9;",
            "    else if(r >= en and l <= st) return seg[ind];",
            "    else{",
            "        if(st==en) return seg[ind];",
            "        auto a = getans(l,r,left);",
            "        auto b = getans(l,r,right);",
            "        auto c = $10",
            "        return c;",
            "    }",
            "}",
            ""
        ],
        "description": "SEgment tree'"
    },
    "sqrtdecomp": {
        "prefix": "sqrtdecomp",
        "body": [
            "const int blocksize = 447;",
            "",
            "struct Query {",
            "    int begin, end, order;",
            "    Query() {}",
            "    bool operator<(Query q) {",
            "        if(this->begin/blocksize == q.begin/blocksize) {",
            "            if((this->begin/blocksize)%2) ",
            "                return this->end > q.end;",
            "            else",
            "                return this->end < q.end;",
            "        } else {",
            "            return this->begin/blocksize < q.begin/blocksize;",
            "        }",
            "    }",
            "};",
            "",
            "void solve()",
            "{",
            "    int n,q;",
            "    cin >> n >> q; ",
            "    vi v(n);",
            "    cin >> v;",
            "    vector<Query> query(q);",
            "    vector<int> answer(q);",
            "    rep(i,0,q) {",
            "        cin >> query[i].begin >> query[i].end;",
            "        query[i].begin--, query[i].end--;",
            "        query[i].order = i;",
            "    }",
            "",
            "    sort(all(query));",
            "",
            "    int l = query[0].begin, r = query[0].begin;",
            "    int ans = 0;",
            "",
            "    for(int i=0;i<q;i++){",
            "        while(r < query[i].end) {",
            "            r++;",
            "        }",
            "        while(l > query[i].begin) {",
            "            l--;",
            "        }",
            "        while(l < query[i].begin) {",
            "            l++;",
            "        }",
            "        while(r > query[i].end) {",
            "            r--;",
            "        }",
            "        answer[query[i].order] = ans;",
            "    }",
            "",
            "    for(auto i:answer) cout << i << endl;",
            "}"
        ],
        "description": "sqrtdecomp"
    },
    "Basic trie": {
        "prefix": "basictrie",
        "body": [
            "struct trieNode{",
            "    char ch;",
            "    int ending;",
            "    map<char, trieNode*> pointers;",
            "    trieNode* parent;",
            "    trieNode(){",
            "        ch = '\\0';",
            "        ending = 0;",
            "        pointers.clear();",
            "        parent = nullptr;",
            "    }",
            "};",
            "",
            "class trie{",
            "    public:",
            "    trieNode *root;",
            "    trie()",
            "    {",
            "        root = new trieNode;",
            "        root->ending = 0;",
            "        root->ch = '\\0';",
            "        root->parent = nullptr;",
            "    }",
            "    int count(string s){",
            "        trieNode *ptr = root;",
            "        int p = 0;",
            "        while(p < s.size() and ptr->pointers.find(s[p])!=ptr->pointers.end()){",
            "            ptr = ptr->pointers[s[p]];",
            "            p++;",
            "        }",
            "        if(p < s.size()) return 0;",
            "        else return ptr->ending;",
            "    }",
            "    void insert(string s){",
            "        trieNode *ptr = root;",
            "        for(int i=0;i<s.size();i++){",
            "            if(ptr->pointers.find(s[i]) == ptr->pointers.end())",
            "                ptr->pointers[s[i]] = new trieNode,",
            "                ptr->pointers[s[i]]->ch = s[i];",
            "                ptr->pointers[s[i]]->parent = ptr;",
            "                ptr = ptr->pointers[s[i]];",
            "        }",
            "        ptr->ending++;",
            "    }",
            "",
            "    void remove(string s){",
            "        if(count(s) == 0) return;",
            "        trieNode *ptr = root;",
            "        for(char c:s){",
            "            ptr = ptr->pointers[c];",
            "        }",
            "        ptr->ending--;",
            "        while(ptr->parent != nullptr){",
            "            char c;",
            "            if(ptr->pointers.empty() and ptr->ending == 0){",
            "                c = ptr->ch;",
            "                ptr = ptr->parent;",
            "                delete ptr->pointers[c];",
            "                ptr->pointers[c] = nullptr;",
            "                ptr->pointers.erase(c);",
            "            }",
            "            else break;",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "Basic implementation of Trie"
    },
    "modular integers": {
        "prefix": "modular",
        "body": [
            "long long binExpp(long long a,long long b,long long modulo)",
            "{",
            "    long long prod = a;",
            "    long long ans = 1;",
            "    while(b){",
            "        if(b%2) ans = (ans*prod)%modulo;",
            "        b /= 2;",
            "        prod = (prod*prod)%modulo;",
            "    }",
            "    return ans;",
            "}",
            "",
            "template<const int mod>",
            "class Mint{",
            "    long long val;",
            "",
            "    public: ",
            "    Mint(long long _val){",
            "        val = (_val%mod+mod)%mod;",
            "    }",
            "    Mint(){",
            "        val = 0;",
            "    }",
            "    Mint operator+(Mint b){",
            "        return Mint((this->val+b.val)%mod);",
            "    }",
            "    Mint operator-(Mint b){",
            "        return Mint(this->val-b.val+mod)%mod;",
            "    }",
            "    Mint operator*(Mint b){",
            "        return Mint((this->val*b.val)%mod);",
            "    }",
            "    Mint operator/(Mint b){",
            "        return (Mint(binExpp(b(), mod-2, mod))*(*this));",
            "    }",
            "    long long &operator()(){",
            "        return val;",
            "    }",
            "    Mint operator+=(Mint b){",
            "        return *this = *this+b;",
            "    }",
            "    Mint operator-=(Mint b){",
            "        return *this = *this-b;",
            "    }",
            "    Mint operator*=(Mint b){",
            "        return *this = *this*b;",
            "    }",
            "    Mint operator/=(Mint b){",
            "        return *this = *this/b;",
            "    }",
            "    int operator%(int modulo){",
            "        return val%modulo;",
            "    }",
            "    int operator%(Mint modulo){",
            "        return val%(modulo());",
            "    }",
            "    Mint operator++(){",
            "        return *this = *this+Mint(1);",
            "    }",
            "    Mint operator= (int x){",
            "        return (*this).val = (x%mod+mod)%mod;",
            "    }",
            "    Mint operator^(Mint pow){",
            "        return Mint(binExpp((*this)(),pow(),mod));",
            "    }",
            "};",
            "template<const int mod>",
            "istream &operator>>(istream &in, Mint<mod> &a)",
            "{",
            "    return in >> a();",
            "}",
            "template<const int mod>",
            "ostream &operator<<(ostream &outt, Mint<mod> a)",
            "{",
            "    return outt<<a();",
            "}",
            "template<const int mod>",
            "Mint<mod> operator+(int mul, Mint<mod> m){",
            "    return m+mul;",
            "}",
            "template<const int mod>",
            "Mint<mod> operator*(int mul, Mint<mod> m){",
            "    return m*Mint<mod>(mul);",
            "}",
            "template<const int mod>",
            "vector<Mint<mod>> Factorial(int n)",
            "{",
            "    vector<Mint<mod>> fact(n+1);",
            "    fact[0] = 1;",
            "    for(int i=1;i<=n;i++) fact[i] = i*fact[i-1];",
            "    return fact;",
            "}",
            "",
            "using mint = Mint<1000000007>;",
            "using mint2 = Mint<998244353>;",
            "using vmi = vector<mint>;"
        ],
        "description": "modular"
    },
    "randomstuff": {
        "prefix": "randomstuff",
        "body": [
            "",
            "#define rnd(x, y) uniform_int_distribution<long long int>(x, y)(rng)",
            "inline int randomIndex(int maxInd) {",
            "    return abs(int(rng()))%maxInd; ",
            "}",
            "",
            "",
            "template<typename T>",
            "inline void randomShuffle(vector<T> &v){",
            "    for(int i=0;i<v.size();i++){",
            "        int j = randomIndex(i+1);",
            "        swap(v[j],v[i]);",
            "    }",
            "}",
            "",
            "template<typename T>",
            "inline void randomShuffle(T *arr, int sz){",
            "    for(int i=0;i<sz;i++){",
            "        int j = randomIndex(i+1);",
            "        swap(arr[j],arr[i]);",
            "    }",
            "}"
        ],
        "description": "randomstuff"
    },
    "hashing": {
        "prefix": "hashing",
        "body": [
            "constexpr int largeprimes[] = {1000000007,1000000009,1000000021,1000000033,1000000087,1000000093,1000000097,1000000103,1000000123,1000000181,1000000207,1000000223,1000000241};",
            "template<const int mod1, const int mod2, const int base = 31>",
            "struct Hash{",
            "    private:",
            "    long long baseInverse1, baseInverse2;",
            "    long long lenPow1, lenPow2;",
            "    public:",
            "    long long hash1, hash2;",
            "    int length;",
            "    Hash(string s){",
            "        baseInverse1 = binPow(base,mod1-2,mod1);",
            "        baseInverse2 = binPow(base,mod2-2,mod2);",
            "        hash1 = hash2 = length = 0;",
            "        for(auto i:s){",
            "            hash1 *= (base);",
            "            hash2 *= (base);",
            "            hash1 += (i-'a'+1);",
            "            hash2 += (i-'a'+1);",
            "            hash1 %= mod1;",
            "            hash2 %= mod2;",
            "            length++;",
            "        }",
            "        lenPow1 = binPow(base,length,mod1);",
            "        lenPow2 = binPow(base,length,mod2);",
            "    }",
            "    Hash(){",
            "        baseInverse1 = binPow(base,mod1-2,mod1);",
            "        baseInverse2 = binPow(base,mod2-2,mod2);",
            "        lenPow1 = lenPow2 = 1;",
            "        hash1 = hash2 = length = 0;",
            "    }",
            "    bool operator==(const Hash h){",
            "        return (this->hash1==h.hash1 and this->hash2==h.hash2 and this->length == h.length);",
            "    }",
            "    void push_back(char c){",
            "        hash1 *= (base);",
            "        hash2 *= (base);",
            "        hash1 += (c-'a'+1);",
            "        hash2 += (c-'a'+1);",
            "        hash1 %= mod1;",
            "        hash2 %= mod2;",
            "        lenPow1 = (lenPow1*base)%mod1;",
            "        lenPow2 = (lenPow2*base)%mod2;",
            "        length++;",
            "    }",
            "    void push_front(char c){",
            "        hash1 += (c-'a'+1)*lenPow1;",
            "        hash1 %= mod1;",
            "        hash2 += (c-'a'+1)*lenPow2;",
            "        hash2 %= mod2;",
            "        lenPow1 = (lenPow1*base)%mod1;",
            "        lenPow2 = (lenPow2*base)%mod2;",
            "        length++;",
            "    }",
            "    void pop_back(char c){",
            "        hash1 -= (c-'a'+1);",
            "        hash1 *= baseInverse1;",
            "        hash1 %= mod1;",
            "        hash2 -= (c-'a'+1);",
            "        hash2 *= baseInverse2;",
            "        hash2 %= mod2;",
            "        lenPow1 = (lenPow1*baseInverse1)%mod1;",
            "        lenPow2 = (lenPow2*baseInverse2)%mod2;",
            "        length--;",
            "    }",
            "    void pop_front(char c){",
            "        lenPow1 = (lenPow1*baseInverse1)%mod1;",
            "        lenPow2 = (lenPow2*baseInverse2)%mod2;",
            "        hash1 -= ((c-'a'+1)*lenPow1)%mod1;",
            "        hash1 %= mod1;",
            "        hash1 += mod1;",
            "        hash1 %= mod1;",
            "        hash2 -= ((c-'a'+1)*lenPow2)%mod2;",
            "        hash2 %= mod2;",
            "        hash2 += mod2;",
            "        hash2 %= mod2;",
            "        length--;",
            "    }",
            "};",
            "",
            "template<const int m1, const int m2>",
            "ostream &operator<<(ostream &ost, Hash<m1,m2> h){",
            "    ost << \"{\" << h.hash1 << \", \" << h.hash2 << \"}\\n\";",
            "    return ost;",
            "}",
            "",
            "template<const int m1, const int m2>",
            "bool operator<(Hash<m1,m2> h1, Hash<m1,m2> h2){",
            "    return make_pair(h1.hash1, make_pair(h1.hash2,h1.length)) < make_pair(h2.hash1, make_pair(h2.hash2,h2.length));",
            "}",
            ""
        ],
        "description": "hashing"
    },
    "Alternate segment tree": {
        "prefix": "altsegment",
        "body": [
            "template<typename T>",
            "struct Merge{",
            "    T operator()(T &a, T &b){",
            "        ",
            "    }",
            "};",
            "",
            "template<typename T>",
            "struct update{",
            "    T operator()(T a, T b){",
            "        ",
            "    }",
            "};",
            "",
            "template<typename T, typename _merge, typename _update>",
            "struct segment_tree",
            "{",
            "    int size;",
            "    T *seg;",
            "    T neutral_element;",
            "    _merge __merge;",
            "    _update __update;",
            "    template<typename U>",
            "    void make_tree(U init, int st, int en, int index){",
            "        if(st == en) seg[index] = vi({init[st]});",
            "        else{",
            "            make_tree(init,st, (st+en)/2 ,2*index+1);",
            "            make_tree(init,(st+en)/2+1,en,2*index+2);",
            "            seg[index] = __merge(seg[2*index+1],seg[2*index+2]);",
            "        }",
            "    }",
            "    void make_tree(int st, int en, int index){",
            "        if(st == en) seg[index] = neutral_element;",
            "        else{",
            "            make_tree(st, (st+en)/2 ,2*index+1);",
            "            make_tree((st+en)/2+1,en,2*index+2);",
            "            seg[index] = __merge(seg[2*index+1],seg[2*index+2]);",
            "        }",
            "    }",
            "",
            "    template<typename U>",
            "    segment_tree(U init, int _size,  T _neutral_element){",
            "        size = _size;",
            "        neutral_element = _neutral_element;",
            "        seg = new T[4*size];",
            "        make_tree(init,0,size-1,0);",
            "    }",
            "    segment_tree(int _size,  T _neutral_element){",
            "        size = _size;",
            "        neutral_element = _neutral_element;",
            "        seg = new T[4*size];",
            "        make_tree(0,size-1,0);",
            "    }",
            "",
            "    void update(int pos, int val, int st, int en, int index)",
            "    {",
            "        if(pos > en or pos < st) return;",
            "        else if(st==en){",
            "            seg[index] = __update(seg[index],val);",
            "        }",
            "        else{",
            "            update(pos,val,st, (st+en)/2 ,2*index+1);",
            "            update(pos,val,(st+en)/2+1,en,2*index+2);",
            "            seg[index] = __merge(seg[2*index+1],seg[2*index+2]);",
            "        }",
            "    }",
            "",
            "    void update(int pos, int val){",
            "        update(pos,val,0,size-1,0);",
            "    }",
            "",
            "    T query(int l, int r){",
            "        return query(l,r,0,size-1,0);",
            "    }",
            "    T query(int l, int r, int st, int en, int index){",
            "        if(r < st or l > en) return neutral_element;",
            "        else if(r >= en and l <= st) return seg[index];",
            "        else{",
            "            if(st==en) return seg[index];",
            "            auto a = query(l,r,st, (st+en)/2 ,2*index+1);",
            "            auto b = query(l,r,(st+en)/2+1,en,2*index+2);",
            "            auto c = __merge(a,b);",
            "            return c;",
            "        }",
            "    }",
            "};",
            "",
            "template<typename T>",
            "using segTree = segment_tree<T, Merge<T>,update<T>>;",
            ""
        ],
        "description": "alternate segment tree"
    },
    "matrix": {
        "prefix": "matrix",
        "body": [
            "template<long long modulo>",
            "struct matrix{",
            "\tvector<vector<long long>> mat;",
            "\tint row, col;",
            "\tmatrix(long long _row, long long _col){",
            "\t\trow = _row, col = _col;",
            "\t\tmat.assign(row, vector<long long>(col,0));",
            "\t}",
            "\tvector<long long> &operator[](long long r){",
            "\t\tif(r >= mat.size()) throw;",
            "\t\treturn mat[r];",
            "\t}",
            "",
            "\tmatrix operator*(matrix &m){",
            "\t\tif(m.row != this->col){",
            "\t\t\tthrow;",
            "\t\t}",
            "\t\tmatrix res(this->row, m.col);",
            "\t\tfor(int i=0;i<this->row;i++){",
            "\t\t\tfor(int j=0;j<m.col;j++){",
            "\t\t\t\tfor(int k=0;k<m.row;k++){",
            "\t\t\t\t\tres[i][j] = (res[i][j] + (((*this)[i][k])*m[k][j])%modulo)%modulo;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "\tvector<vector<long long>>::iterator begin(){",
            "\t\treturn mat.begin();",
            "\t}",
            "",
            "\tvector<vector<long long>>::iterator end(){",
            "\t\treturn mat.end();",
            "\t}",
            "",
            "\tvoid operator=(matrix m){",
            "\t\tthis->mat = m.mat;",
            "\t\tthis->row = m.row;",
            "\t\tthis->col = m.col;",
            "\t}",
            "};",
            "",
            "template<long long modulo>",
            "matrix<modulo> Identity(int sz){",
            "\tmatrix<modulo> res(sz,sz);",
            "\tfor(int i=0;i<sz;i++){",
            "\t\tres[i][i] = 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "template<long long modulo> ostream &operator<<(ostream &ost, matrix<modulo> m){for(auto &i:m){for(auto &j:i) ost << j << \" \";ost << endl;}return ost;}",
            "template<long long modulo> istream &operator>>(istream &ist, matrix<modulo> &m){for(auto &i:m)for(auto &j:i) ist>>j;return ist;}",
            "",
            "",
            "template<long long modulo>",
            "matrix<modulo> matrixExpo(matrix<modulo> &m, long long power){",
            "\tif(m.row != m.col) throw;",
            "\tmatrix<modulo> res = Identity<modulo>(m.row);",
            "\tauto prod = m;",
            "\twhile(power){",
            "\t\tif((power&1)) res = res*prod;",
            "\t\tprod = (prod*prod);",
            "\t\tpower /= 2;",
            "\t}",
            "\treturn res;",
            "}",
            ""
        ],
        "description": "matrix"
    },
    "doublematrix": {
        "prefix": "doublematrix",
        "body": [
            "",
            "struct matrix{",
            "\tvector<vector<double>> mat;",
            "\tint row, col;",
            "\tmatrix(long long _row, long long _col){",
            "\t\trow = _row, col = _col;",
            "\t\tmat.assign(row, vector<double>(col,0));",
            "\t}",
            "\tvector<double> &operator[](long long r){",
            "\t\tif(r >= mat.size()) throw;",
            "\t\treturn mat[r];",
            "\t}",
            "",
            "\tmatrix operator*(matrix &m){",
            "\t\tif(m.row != this->col){",
            "\t\t\tthrow;",
            "\t\t}",
            "\t\tmatrix res(this->row, m.col);",
            "\t\tfor(int i=0;i<this->row;i++){",
            "\t\t\tfor(int j=0;j<m.col;j++){",
            "\t\t\t\tfor(int k=0;k<m.row;k++){",
            "\t\t\t\t\tres[i][j] += (((*this)[i][k])*m[k][j]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "\tvector<vector<double>>::iterator begin(){",
            "\t\treturn mat.begin();",
            "\t}",
            "",
            "\tvector<vector<double>>::iterator end(){",
            "\t\treturn mat.end();",
            "\t}",
            "",
            "\tvoid operator=(matrix m){",
            "\t\tthis->mat = m.mat;",
            "\t\tthis->row = m.row;",
            "\t\tthis->col = m.col;",
            "\t}",
            "};",
            "",
            "matrix Identity(int sz){",
            "\tmatrix res(sz,sz);",
            "\tfor(int i=0;i<sz;i++){",
            "\t\tres[i][i] = 1;",
            "\t}",
            "\treturn res;",
            "}",
            "ostream &operator<<(ostream &ost, matrix m){for(auto &i:m){for(auto &j:i) ost << j << \" \";ost << endl;}return ost;}",
            "istream &operator>>(istream &ist, matrix &m){for(auto &i:m)for(auto &j:i) ist>>j;return ist;}",
            "",
            "",
            "matrix matrixExpo(matrix &m, long long power){",
            "\tif(m.row != m.col) throw;",
            "\tmatrix res = Identity(m.row);",
            "\tauto prod = m;",
            "\twhile(power){",
            "\t\tif((power&1)) res = res*prod;",
            "\t\tprod = (prod*prod);",
            "\t\tpower /= 2;",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "doublematrix"
    },
    "dsuint": {
        "prefix": "dsuint",
        "body": [
            "class DSU {",
            "    vector<int> root;",
            "    vector<int> sz;",
            "public:",
            "    int find(int x) {",
            "        if (root[x] != x) root[x] = find(root[x]);",
            "        return root[x];",
            "    }",
            "    void join(int x, int y) {",
            "        x = find(x);",
            "        y = find(y);",
            "        if (x == y) return;",
            "        if (sz[x] > sz[y]) swap(x, y);",
            "        root[x] = y;",
            "        sz[y] += sz[x];",
            "        sz[x] = 0;",
            "    }",
            "    DSU(int n) {",
            "        root = vector<int>(n+1);",
            "        sz = vector<int>(n+1,1);",
            "        iota(root.begin(), root.end(), 0);",
            "    }",
            "};"
        ],
        "description": "dsuint"
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "",
            "template<typename T>",
            "class DSU {",
            "    map<T,T> root;",
            "    map<T,int> sz;",
            "public:",
            "    DSU() {}",
            "    void init(T val) {",
            "        if(!root.count(val)) {",
            "            root[val] = val;",
            "            sz[val] = 1;",
            "        }",
            "    }",
            "",
            "    T find(T val, bool create = true) {",
            "        if(!root.count(val)) {",
            "            if(!create) return T();",
            "            init(val);",
            "            return val;",
            "        }",
            "        if(root[val] == val) return val;",
            "        return root[val] = find(root[val], create);",
            "    }",
            "",
            "    void join(T a, T b, bool create = true) {",
            "        a = find(a,create);",
            "        b = find(b,create);",
            "        if(a == b) return;",
            "        if(sz[a] > sz[b]) {",
            "            swap(a, b);",
            "        }",
            "        root[b] = a;",
            "        sz[a] += sz[b];",
            "        sz[a] = 0;",
            "    }",
            "};",
            ""
        ],
        "description": "dsu"
    },
    "HLD": {
        "prefix": "HLD",
        "body": [
            "#define func max",
            "",
            "vvi parent;",
            "vi depth, label, toc, subsize, seg, vals;",
            "int mxN = 20;",
            "",
            "void dfsone(int src, int par, vi *adj, int dep=0){",
            "    depth[src] = dep;",
            "    parent[src][0] = par;",
            "    subsize[src] = 1;",
            "    for(int i=1;i<mxN;i++){",
            "        parent[src][i] = parent[parent[src][i-1]][i-1];",
            "    }",
            "    for(auto i:adj[src]){",
            "        if(i == par) continue;",
            "        dfsone(i,src,adj,dep+1);",
            "        subsize[src] += subsize[i];",
            "    }",
            "}",
            "",
            "int timer = 0;",
            "",
            "void dfstwo(int src, int parent, vi *adj, bool heavy){",
            "    label[src] = timer++;",
            "    toc[src] = ((heavy)?toc[parent]:src);",
            "    int mx=0,pos=-1;",
            "    for(auto i:adj[src]) {",
            "        if(i == parent) continue;",
            "        if(subsize[i] > mx){",
            "            mx = subsize[i];",
            "            pos = i;",
            "        }",
            "    }",
            "    if(pos != -1)dfstwo(pos,src,adj,1);",
            "    for(auto i:adj[src]) {",
            "        if(i == parent) continue;",
            "        if(i == pos) continue;",
            "        else {",
            "            dfstwo(i,src,adj,0);",
            "        }",
            "    }",
            "}",
            "",
            "void update(int pos, int val, int st, int en, int ind, vi &seg)",
            "{",
            "    if(pos > en or pos < st) return;",
            "    else if(st==en){",
            "        seg[ind] = val;",
            "    }",
            "    else{",
            "        update(pos,val,left);",
            "        update(pos,val,right);",
            "        seg[ind] = func(seg[ridx], seg[lidx]);",
            "    }",
            "}",
            "",
            "int getans(int l, int r, int st, int en, int ind, vi &seg)",
            "{",
            "    if(l > r) swap(l,r);",
            "    if(r < st or l > en) return intmin;",
            "    else if(r >= en and l <= st) return seg[ind];",
            "    else{",
            "        if(st==en) return seg[ind];",
            "        auto a = getans(l,r,left);",
            "        auto b = getans(l,r,right);",
            "        auto c = func(a,b);",
            "        return c;",
            "    }",
            "}",
            "",
            "",
            "auto lca = [](int u, int v){",
            "    if(depth[u] < depth[v]) swap(u,v);",
            "    drep(i,mxN-1,0) if(depth[u]-(1<<i) >= depth[v]) u = parent[u][i];",
            "    if(u == v) return v;",
            "    drep(i,mxN-1,0) {",
            "        if(parent[u][i] != parent[v][i]){",
            "            u = parent[u][i];",
            "            v = parent[v][i];",
            "        }",
            "    }",
            "    return parent[u][0];",
            "};",
            "",
            "void solve()",
            "{",
            "    int n, q;",
            "    cin >> n >> q;",
            "    vi adj[n+1];",
            "    vals.resize(n+1);",
            "    rep(i,1,n+1) cin >> vals[i];",
            "    makegraph(adj,n-1);",
            "    parent.assign(n+1, vi(mxN, 0));",
            "    depth.resize(n+1);",
            "    label.resize(n+1);",
            "    toc.resize(n+1);",
            "    subsize.resize(n+1);",
            "    seg.resize(4*n);",
            "    dfsone(1,0,adj);",
            "    dfstwo(1,0,adj,false);",
            "    trace(label);trace(vals);trace(depth);trace(subsize);",
            "    rep(i,1,n+1) {",
            "        update(label[i],vals[i],0,n-1,0,seg);",
            "    }",
            "    while(q--) {",
            "        newint(type,x,y);",
            "        if(type == 1) {",
            "            update(label[x],y,0,n-1,0,seg);",
            "            vals[x] = y;",
            "        } else {",
            "            int l = lca(x,y);",
            "            trace(x,y,l);",
            "            int ans1 = vals[x], ans2 = vals[y];",
            "            int node1 = x, node2 = y;",
            "            while(node1 != l) {",
            "                if(toc[node1] == node1) {",
            "                    node1 = parent[node1][0];",
            "                    ans1 = func(ans1, vals[node1]);",
            "                }",
            "                else if(depth[toc[node1]] >= depth[l]) {",
            "                    ans1 = func(ans1, getans(label[toc[node1]],label[node1],0,n-1,0,seg));",
            "                    node1 = toc[node1];",
            "                } else {",
            "                    ans1 = func(ans1, getans(label[l], label[node1], 0, n-1, 0, seg));",
            "                    node1 = l;",
            "                }",
            "            }",
            "            while(node2 != l) {",
            "                if(toc[node2] == node2) {",
            "                    node2 = parent[node2][0];",
            "                    ans2 = func(ans2, vals[node2]);",
            "                }",
            "                else if(depth[toc[node2]] >= depth[l]) {",
            "                    ans2 = func(ans2, getans(label[toc[node2]],label[node2],0,n-1,0,seg));",
            "                    node2 = toc[node2];",
            "                } else {",
            "                    ans2 = func(ans2, getans(label[l], label[node2],0,n-1,0,seg));",
            "                    node2 = l;",
            "                }",
            "            }",
            "            cout << func(ans1,ans2) << endl;",
            "        }",
            "    }",
            "    cout << endl;",
            "}"
        ],
        "description": "HLD"
    },
    "ezbs": {
        "prefix": "ezbs",
        "body": [
            "template<typename T, T (*func)(int)>",
            "class range {",
            "    int startIndex, endIndex;",
            "    public:",
            "    class iterator {",
            "        int index;",
            "        public:",
            "        using iterator_category = std::random_access_iterator_tag;",
            "        using difference_type   = std::ptrdiff_t;",
            "        using value_type        = T;",
            "        using pointer           = T*;",
            "        using reference         = T;",
            "        iterator(int idx) {",
            "            index = idx;",
            "        }",
            "        T operator*() const {",
            "            return func(index);",
            "        }",
            "        iterator &operator++(){",
            "            this->index++;",
            "            return *this;",
            "        }",
            "        iterator &operator--(){",
            "            this->index--;",
            "            return *this;",
            "        }",
            "        iterator operator++(int32_t) {",
            "            iterator tmp = *this;",
            "            ++(*this);",
            "            return tmp;",
            "        }",
            "        iterator operator--(int32_t) {",
            "            iterator tmp = *this;",
            "            --(*this);",
            "            return tmp;",
            "        }",
            "        iterator operator+(int x) {",
            "            return iterator(index+x);",
            "        }",
            "        iterator operator+=(int x) {",
            "            this->index += x;",
            "            return *this;",
            "        }",
            "        iterator operator-(int x) {",
            "            return iterator(index+x);",
            "        }",
            "        difference_type operator-(const iterator &a) {",
            "            return this->index-a.index;",
            "        }",
            "        iterator operator-=(int x) {",
            "            this->index -= x;",
            "            return *this;",
            "        }",
            "        int position() {",
            "            return index;",
            "        }",
            "        difference_type distance(iterator a, iterator b) {",
            "            return b.index-a.index;",
            "        }",
            "        friend bool operator!=(const iterator &a, const iterator &b) {",
            "            return a.index != b.index;",
            "        }",
            "        friend bool operator==(const iterator &a, const iterator &b) {",
            "            return a.index == b.index;",
            "        }",
            "    };",
            "    range(int st, int en) {",
            "        startIndex = st;",
            "        endIndex = en;",
            "    }",
            " ",
            "    iterator begin() {",
            "        return iterator(startIndex);",
            "    }",
            " ",
            "    iterator end() {",
            "        return iterator(endIndex);",
            "    }",
            "};"
        ],
        "description": "ezbs"
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "#define time(function_name, ...) {Timer t(#function_name); function_name(__VA_ARGS__);}",
            "#define Time(var,function_name,...){Timer t(#function_name); var = function_name(__VA_ARGS__);}",
            "class Timer {",
            "    string name;",
            "    decltype(chrono::high_resolution_clock::now()) startTime, endTime;",
            "    public:",
            "    #ifndef ONlINE_JUDGE",
            "    Timer(string s) {",
            "        name = s;",
            "        startTime = chrono::high_resolution_clock::now();",
            "    }",
            "    ~Timer() {",
            "        endTime = chrono::high_resolution_clock::now();",
            "        cerr << name << \" took \" << chrono::duration_cast<chrono::milliseconds>(endTime-startTime).count() << \"ms\" << endl;",
            "    }",
            "    #else",
            "    Timer(string s) {}",
            "    #endif",
            "};"
        ],
        "description": "timer"
    },
    "stringmatching": {
        "prefix": "stringmatching",
        "body": [
            "",
            "struct _contains_ {string_view _;_contains_(){}};",
            "_contains_ operator<(string s, _contains_ C) {_contains_ c;c._ = s;return c;}",
            "bool operator>(_contains_ c, string s){const int p = 31; const int m = 1e9 + 9;int S = s.size(), T = c._.size();vector<long long> p_pow(max(S, T)); p_pow[0] = 1; for (int i = 1; i < (int)p_pow.size(); i++) {p_pow[i] = (p_pow[i-1] * p) % m;}vector<long long> h(T + 1, 0); for (int i = 0; i < T; i++) {h[i+1] = (h[i] + (c._[i] - 'a' + 1) * p_pow[i]) % m;}long long h_s = 0; for (int i = 0; i < S; i++) {h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m;} for (int i = 0; i + S - 1 < T; i++) { long long cur_h = (h[i+S] + m - h[i]) % m; if (cur_h == h_s * p_pow[i] % m){return true;}}return false;}",
            "#define has <_contains_()>",
            "",
            ""
        ],
        "description": "stringmatching"
    },
    "orderedms": {
        "prefix": "orderedms",
        "body": [
            "struct ordered_multiset {",
            "    struct Node {",
            "        int m_value;",
            "        pair<int,int> m_range;",
            "        Node *m_left, *m_right;",
            "        inline Node(int left, int right) {",
            "            m_range = {left, right};",
            "            m_left = m_right = nullptr;",
            "            m_value = 0;",
            "        }",
            "        inline int value() {",
            "            return m_value;",
            "        }",
            "        inline Node *left() {",
            "            return m_left;",
            "        }",
            "        inline Node *right() {",
            "            return m_right;",
            "        }",
            "        inline pair<int,int> range() {",
            "            return m_range;",
            "        }",
            "        ~Node() {",
            "            delete m_left;",
            "            delete m_right;",
            "        }",
            "    };",
            "    Node *m_root;",
            "    void segtree_update(int pos, int val, Node *root) {",
            "        if(root->range() == make_pair(pos, pos)) {",
            "            root->m_value += val;",
            "            return;",
            "        }",
            "        if(root->range().first == root->range().second) return;",
            "        int mid = (root->range().first + root->range().second)/2;",
            "        if(not root->left()) {",
            "            root->m_left = new Node(root->range().first, mid);",
            "            root->m_right = new Node(mid+1, root->range().second);",
            "        }",
            "        if(pos > mid) segtree_update(pos, val, root->m_right);",
            "        else segtree_update(pos, val, root->m_left);",
            "        root->m_value = root->m_left->m_value + root->m_right->m_value;",
            "    }",
            "    int segtree_query(int l, int r, Node *root) {",
            "        if(l <= root->range().first and root->range().second <= r) return root->value();",
            "        if(root->range().first > r or root->range().second < l) return 0;",
            "        if(not root->left()) {",
            "            int mid = (root->range().first + root->range().second)/2;",
            "            root->m_left = new Node(root->range().first, mid);",
            "            root->m_right = new Node(mid+1, root->range().second);",
            "        }",
            "        return segtree_query(l, r, root->m_left) + segtree_query(l, r, root->m_right);",
            "    }",
            "    inline ordered_multiset(int l_bount=0, int u_bound=1000000000) {",
            "        m_root = new Node(l_bount, u_bound);",
            "    }",
            "",
            "    inline bool contains(int key) {",
            "        return (segtree_query(key, key, m_root) > 0);",
            "    }",
            "",
            "    inline int count(int key) {",
            "        return segtree_query(key, key, m_root);",
            "    }",
            "",
            "    inline void insert(int key) {",
            "        segtree_update(key, 1, m_root);",
            "    }",
            "    ",
            "    inline int size() {",
            "        return m_root->value();",
            "    }",
            "",
            "    //Removes one copy of the key",
            "    inline void remove(int key) {",
            "        segtree_update(key, -1, m_root);",
            "    }",
            "",
            "    //Removes all copies of the key",
            "    inline void erase(int key) {",
            "        segtree_update(key, -segtree_query(key,key,m_root), m_root);",
            "    }",
            "    inline int find_by_order(size_t order) {",
            "        if(order >= size()) return m_root->range().second+1;",
            "        Node *cur = m_root;",
            "        while(cur->left()) {",
            "            int mid = (cur->range().first + cur->range().second)/2;",
            "            if(order < cur->left()->value()) cur = cur->left();",
            "            else {",
            "                order -= cur->left()->value();",
            "                cur = cur->right();",
            "            }",
            "        }",
            "        return cur->range().first;",
            "    }",
            "    inline int order_of_key(int key) {",
            "        return segtree_query(m_root->range().first, key-1, m_root);",
            "    }",
            "    vector<int> elements() {",
            "        vector<int> v;",
            "        stack<Node *> s;",
            "        s.push(m_root);",
            "        while(!s.empty()) {",
            "            Node *cur = s.top();",
            "            s.pop();",
            "            if(cur->left() and cur->left()->value()) s.push(cur->left());",
            "            if(cur->right() and cur->right()->value()) s.push(cur->right());",
            "            if(cur->range().first == cur->range().second) {",
            "                for(int i=0;i<cur->value();i++) v.push_back(cur->range().first);",
            "            }",
            "        }",
            "        reverse(v.begin(), v.end());",
            "        return v;",
            "    }",
            "    inline void clear() {",
            "        auto x = new Node(m_root->range().first, m_root->range().second);",
            "        m_root = x;",
            "        delete m_root;",
            "    }",
            "    ~ordered_multiset() {",
            "        delete m_root;",
            "    }",
            "    int lower_bound(int key) {",
            "        return find_by_order(order_of_key(key));",
            "    }",
            "    int upper_bound(int key) {",
            "        return lower_bound(key+1);",
            "    }",
            "};"
        ],
        "description": "orderedms"
    },
    "suffixarray": {
        "prefix": "suffixarray",
        "body": [
            "vector<int> suffix_array(string s) {",
            "    int n = s.size();",
            "    for(int i=0;i<2*n;i++) s += '$';",
            "    vector<int> sa(n),rank(n), temp(n);",
            "    iota(sa.begin(), sa.end(), 0);",
            "    for(int i=0;i<n;i++) rank[i] = s[i]-'a';",
            "    for(int len=2;len<=2*n;len*=2) {",
            "        ",
            "        sort(sa.begin(), sa.end(), [&](int i, int j) {",
            "            if(rank[i] == rank[j]) return rank[len/2+i] < rank[len/2+j];",
            "            return rank[i] < rank[j];",
            "        });",
            "        temp[sa[0]] = 0;",
            "        for(int i=1;i<n;i++) {",
            "            temp[sa[i]] = temp[sa[i-1]];",
            "            if(rank[sa[i]]==rank[sa[i-1]]) {",
            "                if(rank[len/2+sa[i]]!=rank[len/2+sa[i-1]]) {",
            "                    temp[sa[i]]++;",
            "                }",
            "            } else {",
            "                temp[sa[i]]++;",
            "            }",
            "        }",
            "        rank = temp;",
            "    }",
            "    return sa;",
            "}"
        ],
        "description": "suffixarray"
    },
    "kmp": {
        "prefix": "kmp",
        "body": [
            "vector<int> prefix(string s) {",
            "    int n = s.size();",
            "    vector<int> p(n);",
            "    for (int i = 1, j = 0; i < n; i++) {",
            "        while (j > 0 && s[i] != s[j]) j = p[j - 1];",
            "        if (s[i] == s[j]) j++;",
            "        p[i] = j;",
            "    }",
            "    return p;",
            "}"
        ],
        "description": "kmp"
    },
    "zfunc": {
        "prefix": "zfunc",
        "body": [
            "vector<int> Z(string s) {",
            "    int n = s.size();",
            "    vector<int> z(n);",
            "    for (int i = 1, l = 0, r = 0; i < n; i++) {",
            "        if (i <= r) z[i] = min(r - i + 1, z[i - l]);",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;",
            "        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}",
            ""
        ],
        "description": "zfunc"
    },
    "cht": {
        "prefix": "cht",
        "body": [
            "const double inf = 100000000000000.0;",
            "",
            "template<typename T>",
            "struct Line {",
            "    T m,c;",
            "    Line() {",
            "        m = c = 0;",
            "    }",
            "    Line(T m, T c) {",
            "        this->m = m;",
            "        this->c = c;",
            "    }",
            "    auto at(auto x) {",
            "        return m*x + c;",
            "    }",
            "};",
            "",
            "template<typename T, typename U> ",
            "double intersection(Line<T> l1, Line<U> l2) {",
            "    return double(l2.c - l1.c)/double(l1.m - l2.m);",
            "}",
            "",
            "struct Interval {",
            "    double start,end;",
            "    Interval(){",
            "        start = end = 0;",
            "    }",
            "    Interval(double s, double e) {",
            "        start = s, end = e;",
            "    }",
            "};",
            "",
            "template<typename T>",
            "struct Convex_Hull {",
            "    vector<Line<T>> lines;",
            "    vector<Interval> bounds;",
            "    Convex_Hull() {}",
            "",
            "    T at(T point) {",
            "        int index = lower_bound(bounds.begin(), bounds.end(), point, [](Interval i, T point) {",
            "            return i.end < point;",
            "        })-bounds.begin();",
            "        return lines[index].m*point + lines[index].c;",
            "    }",
            "",
            "    void addLine(Line<T> l) {",
            "        while(!lines.empty()) {",
            "            Line<T> line = lines.back();",
            "            if(line.at(bounds.back().start) >= l.at(bounds.back().start)) {",
            "                lines.pop_back();",
            "                bounds.pop_back();",
            "            }",
            "            else break;",
            "        }",
            "",
            "        if(lines.empty()) {",
            "            lines.push_back(l);",
            "            bounds.push_back(Interval(0,inf));",
            "        } ",
            "        else {",
            "            double new_start = intersection(l, lines.back());",
            "            bounds.back().end = new_start;",
            "            lines.push_back(l);",
            "            bounds.push_back(Interval(new_start,inf));",
            "        }",
            "    }",
            "};",
            "",
            "template<typename T>",
            "using CH = Convex_Hull<T>;"
        ],
        "description": "cht"
    },
    "gtbp": {
        "prefix": "gtbp",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define endl '\\n'",
            "#define ll long long",
            "#define all(x) x.begin(), x.end()",
            "#define rep(i,k,n) for(int i = k; i < n; i++)",
            "#define gt return 0",
            "",
            "void solve()",
            "{",
            "    $0",
            "}",
            "",
            "int main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    cout.tie(NULL);",
            "    int t;",
            "    cin >> t;",
            "    while(t--) {",
            "        solve();",
            "    }",
            "    gt;",
            "}"
        ],
        "description": "gtbp"
    },
    "interactive": {
        "prefix": "interactive",
        "body": [
            "struct Judge {",
            "    // Test data variables here",
            "    Judge()",
            "    {",
            "        #ifdef ONLINE_JUDGE",
            "        #else",
            "        // Init test data variables here",
            "        #endif",
            "    }",
            "    int query(int l, int r) {",
            "        #ifdef ONLINE_JUDGE",
            "            cout << \"? \" << l << \" \" << r << endl;",
            "            int result;",
            "            cin >> result;",
            "            return result;",
            "        #else",
            "        // implement logic for query here",
            "        #endif",
            "    }",
            "    int guess(auto x) {",
            "        #ifdef ONLINE_JUDGE",
            "            cout << \"! \" << x << endl;",
            "            return true;",
            "            // int x;",
            "            // cin >> x;",
            "            // return x;",
            "        #else",
            "        // Implement logic for checking here",
            "        #endif",
            "    }",
            "};"
        ],
        "description": "interactive"
    },
    "centroid": {
        "prefix": "centroid",
        "body": [
            "void getSize(int node, vi *adj, vector<bool> &taken, vector<int> &sub, int parent = 0) {",
            "    sub[node] = 1;",
            "    for(auto child:adj[node]) {",
            "        if(child == parent or taken[child]) continue;",
            "        getSize(child,adj,taken,sub,node);",
            "        sub[node] += sub[child];",
            "    }",
            "}",
            "",
            "int getCentroid(int node, vi *adj, vector<bool> &taken, vector<int> &sub, int totalSize, int parent = 0) {",
            "    int mx = 0, mxp = -1;",
            "    for(auto child:adj[node]) {",
            "        if(child == parent or taken[child]) continue;  ",
            "        if(sub[child] > mx) {",
            "            mx = sub[child], mxp = child;",
            "        } ",
            "    }",
            "    if(mx <= totalSize/2) return node;",
            "    return getCentroid(mxp,adj,taken,sub,totalSize,node);",
            "}",
            "",
            "vvi makeCD(int n, vi *adj, int &root) {",
            "    int cnt = 0;",
            "    vector<bool> taken(n+1);",
            "    vi sub;",
            "    vii roots;",
            "    vvi cd_adj(n+1);",
            "    roots.push_back({1,0});",
            "    while(cnt < n)",
            "    {",
            "        sub.assign(n+1,0);",
            "        vii x;",
            "        for(auto [node,parent]:roots) {",
            "            getSize(node,adj,taken,sub);",
            "            int centroid = getCentroid(node,adj,taken,sub,sub[node]);",
            "            taken[centroid] = 1;",
            "            cd_adj[parent].push_back(centroid);",
            "            if(parent)cd_adj[centroid].push_back(parent);",
            "            else root = centroid;",
            "            for(auto i:adj[centroid]) {",
            "                if(!taken[i]) x.push_back({i,centroid});",
            "            }",
            "            cnt++;",
            "        }",
            "        roots = x;",
            "    }",
            "    return cd_adj;",
            "}",
            ""
        ],
        "description": "centroid"
    },
    "ordered_multiset": {
        "prefix": "ordered_multiset",
        "body": [
            "",
            "template<typename T>",
            "class ordered_multiset {",
            "    ordered_set<pair<T,int>> os;",
            "public:",
            "    class iterator {",
            "        ordered_set<pair<T,int>>::iterator it;",
            "        public: ",
            "        using iterator_category = std::bidirectional_iterator_tag;",
            "        using difference_type   = std::ptrdiff_t;",
            "        using value_type        = T;",
            "        using pointer           = T*;",
            "        using reference         = T;",
            "        T operator*() const {",
            "            return it->first;",
            "        }",
            "        iterator(ordered_set<pair<T,int>>::iterator IT) {",
            "            it = IT;",
            "        }",
            "        iterator &operator++(){",
            "            this->it++;",
            "            return *this;",
            "        }",
            "        iterator &operator--(){",
            "            this->it--;",
            "            return *this;",
            "        }",
            "        iterator operator++(int32_t) {",
            "            iterator tmp = *this;",
            "            ++(*this);",
            "            return tmp;",
            "        }",
            "        iterator operator--(int32_t) {",
            "            iterator tmp = *this;",
            "            --(*this);",
            "            return tmp;",
            "        }",
            "        friend bool operator!=(const iterator &a, const iterator &b) {",
            "            return a.it != b.it;",
            "        }",
            "        friend bool operator==(const iterator &a, const iterator &b) {",
            "            return a.it == b.it;",
            "        }",
            "    };",
            "    iterator begin() {",
            "        return iterator(os.begin());",
            "    }",
            "    iterator end() {",
            "        return iterator(os.end());",
            "    }",
            "    iterator lower_bound(T val) {",
            "        return iterator(os.lower_bound(make_pair(val,0)));",
            "    }",
            "    iterator upper_bound(T val) {",
            "        return iterator(os.upper_bound(make_pair(val,INT_MAX)));",
            "    }",
            "    int order_of_key(T val) {",
            "        return os.order_of_key(make_pair(val,0));",
            "    }",
            "    iterator find_by_order(int x) {",
            "        return iterator(os.find_by_order(x));",
            "    }",
            "    int size() {",
            "        return os.size();",
            "    }",
            "    bool empty() {",
            "        return os.empty();",
            "    }",
            "    int count(T val) {",
            "        return os.order_of_key(make_pair(val,INT_MAX))-os.order_of_key(make_pair(val,0));",
            "    }",
            "    void insert(T val) {",
            "        int count_val = count(val);",
            "        if(count_val) os.insert(make_pair(val,count_val));",
            "        else os.insert(make_pair(val,0));",
            "    }",
            "    void erase(T val) {",
            "        if(count(val) == 0) return;",
            "        os.erase(make_pair(val,count(val)-1));",
            "    }",
            "    void eraseAll(T val) {",
            "        int count_val = count(val);",
            "        while (count_val) {",
            "            count_val--;",
            "            os.erase(make_pair(val,count_val));",
            "        }",
            "    }",
            "};"
        ],
        "description": "ordered_multiset"
    },
    "scalingFlow": {
        "prefix": "scalingFlow",
        "body": [
            "int runningIdx = 0;",
            "",
            "struct Edge {",
            "    int u,v;",
            "    int flow, capacity, index;",
            "    Edge(int from, int to, int capacity, int flow) {",
            "        v = to, u = from, this->capacity = capacity, this->flow = flow, index = runningIdx;",
            "    }",
            "};",
            "",
            "ostream &operator<<(ostream &ost, Edge e) {",
            "    ost << e.u << \"->\" << e.v << \" flow: \" << e.flow << \"/\" << e.capacity;",
            "    return ost;",
            "}",
            "",
            "vector<vector<Edge>> adj;",
            "",
            "void addEdge(int u, int v, int cap) {",
            "    adj[u].push_back(Edge(u,v,cap,0));",
            "    adj[v].push_back(Edge(v,u,0,0));",
            "    runningIdx++;",
            "}",
            "",
            "int augment(int source, int sink, int c, int pathMin, vector<bool> &vis, int lastNode = 0, int lastIndex = 0) {",
            "    if(source == sink) {",
            "        for(auto &edge:adj[source]) {",
            "            if(edge.index == lastIndex) edge.flow -= pathMin;",
            "        }",
            "        return pathMin;",
            "    }",
            "    vis[source] = 1;",
            "    for(auto &edge:adj[source]) {",
            "        if(vis[edge.v]) continue;",
            "        int resFlow = edge.capacity-edge.flow;",
            "        if(resFlow >= c) {",
            "            int x = augment(edge.v,sink,c,min(pathMin,resFlow),vis,source,edge.index);",
            "            if(x) {",
            "                if(lastNode) {",
            "                    for(auto &edge:adj[source]) {",
            "                        if(edge.index == lastIndex) edge.flow -= x;",
            "                    }",
            "                }",
            "                edge.flow += x;",
            "                return x;",
            "            }",
            "        }",
            "    }",
            "    return 0;",
            "}",
            "",
            "int maxFlow(int source, int sink) {",
            "    int c = 0;",
            "    for(int i=1;i<adj.size();i++) {",
            "        for(auto edge:adj[i]) {",
            "            c = max(c,edge.capacity);",
            "        }",
            "    }",
            "    int flow = 0;",
            "    while(c) {",
            "        vector<bool> vis(adj.size()+1,false);",
            "        int x = augment(source,sink,c,2*c,vis);",
            "        if(not x) c /= 2;",
            "        else flow += x; ",
            "    }",
            "    return flow;",
            "}",
            ""
        ],
        "description": "scalingFlow"
    },
    "dinitz": {
        "prefix": "dinitz",
        "body": [
            "struct Edge {",
            "    int u,v;",
            "    int flow, capacity;",
            "    Edge(int from, int to, int capacity, int flow) {",
            "        v = to, u = from, this->capacity = capacity, this->flow = flow;",
            "    }",
            "};",
            "",
            "ostream &operator<<(ostream &ost, Edge e) {",
            "    ost << e.u << \"->\" << e.v << \" flow: \" << e.flow << \"/\" << e.capacity;",
            "    return ost;",
            "}",
            "",
            "struct Dinitz {",
            "    int n, m = 0, source, sink;",
            "    vector<Edge> edge;",
            "    vector<vector<int>> adj;",
            "    vector<int> level;",
            "    vector<int> ptr;",
            "    int INF = 2147483648ll*2147483648ll+INT_MAX;",
            "",
            "    Dinitz(int n, int source, int sink) {",
            "        this->n = n, this->source = source, this->sink = sink;",
            "        adj.resize(n+1);",
            "        level.resize(n+1);",
            "        ptr.resize(n+1);",
            "    }",
            "",
            "    void addEdge(int u, int v, int cap) {",
            "        edge.push_back(Edge(u,v,cap,0));",
            "        adj[u].push_back(m++);",
            "        edge.push_back(Edge(v,u,0,0));",
            "        adj[v].push_back(m++);",
            "    }",
            "",
            "    // returns if augmenting path exists",
            "    bool bfs() {",
            "        queue<int> q;",
            "        q.push(source);",
            "        fill(all(level),-1);",
            "        level[source] = 0;",
            "        while (!q.empty())",
            "        {",
            "            int node = q.front();",
            "            q.pop();",
            "            for(auto i:adj[node]) {",
            "                int child = edge[i].v;",
            "                if(level[child] != -1) continue;",
            "                if(edge[i].capacity == edge[i].flow) continue;",
            "                level[child] = level[node]+1;",
            "                q.push(child);",
            "            }",
            "        }",
            "        return level[sink] != -1;",
            "    }",
            "",
            "    //augment and blocks paths",
            "    int dfs(int node, int pathMin) {",
            "        if(pathMin == 0) return 0;",
            "        if(node == sink) return pathMin;",
            "        for(int &i = ptr[node]; i < adj[node].size(); ++i) {",
            "            int child = edge[adj[node][i]].v, resFlow = edge[adj[node][i]].capacity - edge[adj[node][i]].flow;",
            "            if(level[child] != level[node]+1 or resFlow == 0) continue;",
            "            int pushed = dfs(child,min(resFlow,pathMin));",
            "            if(not pushed) continue;",
            "            edge[adj[node][i]].flow += pushed;",
            "            edge[adj[node][i]^1].flow -= pushed;",
            "            return pushed;",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    int maxFlow() {",
            "        int flow = 0;",
            "        while (bfs()) {",
            "            fill(all(ptr),0);",
            "            while(int pushed = dfs(source,INF)) {",
            "                flow += pushed;",
            "            }",
            "        }",
            "        return flow;       ",
            "    }",
            "};"
        ],
        "description": "dinitz"
    },
    "tree": {
        "prefix": "tree",
        "body": [
            "template<bool DP = true>",
            "struct Tree {",
            "    int n;",
            "    vector<int> depth,parent,sub,dp,val;",
            "    vector<vector<int>> adj;",
            "    Tree(int n, int root = 1): n(n) {",
            "        depth.resize(n+1);parent.resize(n+1);",
            "        sub.resize(n+1);adj.resize(n+1);",
            "        if(DP) {",
            "            val.resize(n+1);",
            "            dp.resize(n+1);",
            "            for(int i=1;i<=n;i++) cin >> val[i];",
            "        }",
            "        inputEdges();",
            "        initDFS();",
            "    }",
            "    void inputEdges() {",
            "        for(int i=0;i<n-1;i++) {",
            "            int u,v;",
            "            cin >> u >> v;",
            "            adj[u].push_back(v);",
            "            adj[v].push_back(v);",
            "        }",
            "    }",
            "    void initDFS(int node = 1, int par = 0, int dep = 0) {",
            "        parent[node] = par, depth[node] = dep, sub[node] = 1;",
            "        for(auto child:adj[node]) {",
            "            if(child == par) continue;",
            "            initDFS(child,node,dep+1);",
            "            sub[node] += sub[child];",
            "        }",
            "    }",
            "",
            "    void DFS(int node) {",
            "        // init dp",
            "        for(auto child:adj[node]) {",
            "            if(child == parent[node]) continue;",
            "            DFS(child);",
            "            //combine dp",
            "        }",
            "    }",
            "    ",
            "    int &getSize(int x) {return sub[x];}",
            "    int &getDP(int x) {return dp[x];}",
            "    int &getDepth(int x) {return depth[x];}",
            "    vector<int> &getNeighbours(int x) {return adj[x];}",
            "    int &getParent(int x) {return parent[x];}",
            "};"
        ],
        "description": "tree"
    },
    "sgmt": {
        "prefix": "sgmt",
        "body": [
            "",
            "struct Node {",
            "    int val;",
            "};",
            "",
            "struct Segtree {",
            "    int n;",
            "    vector<Node> tree;",
            "    Node NEUTRAL_ELEMENT;",
            "    Segtree(int n) {",
            "        this->n = n;",
            "        tree.resize(4*n);",
            "        NEUTRAL_ELEMENT = {0};",
            "        build(0,0,n-1);",
            "    }",
            "    Segtree(vector<int> arr) {",
            "        n = arr.size();",
            "        tree.resize(4*n);",
            "        NEUTRAL_ELEMENT = {0};",
            "        build(arr,0,0,n-1);",
            "    }",
            "",
            "    void build(int ind, int st, int en) {",
            "        if(st == en) {",
            "            tree[ind] = NEUTRAL_ELEMENT;",
            "        } else {",
            "            int mid = (st+en)/2;",
            "            build(2*ind+1,st,mid);",
            "            build(2*ind+2,st,mid);",
            "            merge(ind,2*ind+1,2*ind+2);",
            "        }",
            "    }",
            "",
            "    void build(vector<int> &arr, int ind, int st, int en) {",
            "        if(st == en) {",
            "            tree[ind] = {arr[st]};",
            "        } else {",
            "            int mid = (st+en)/2;",
            "            build(arr,2*ind+1,st,mid);",
            "            build(arr,2*ind+2,mid+1,en);",
            "            merge(ind,2*ind+1,2*ind+2);",
            "        }",
            "    }",
            "",
            "    void merge(int ind, int left, int right) {",
            "        tree[ind] = {tree[left].val+tree[right].val};",
            "    }",
            "",
            "    Node merge(Node a, Node b) {",
            "        return {a.val+b.val};",
            "    }",
            "",
            "    void update(int pos, int val) {",
            "        update(pos,val,0,0,n-1);",
            "    }",
            "",
            "    void update(int pos, int val, int ind, int st, int en) {",
            "        if(pos > en or pos < st) return;",
            "        else if(st==en){",
            "            tree[ind] = {val};",
            "        }",
            "        else{",
            "            int mid = (st+en)/2;",
            "            update(pos,val,2*ind+1,st,mid);",
            "            update(pos,val,2*ind+2,mid+1,en);",
            "            merge(ind,2*ind+1,2*ind+2); ",
            "        }",
            "    }",
            "",
            "    Node query(int l, int r) {",
            "        return query(l,r,0,0,n-1);",
            "    }",
            "",
            "    Node query(int l, int r, int ind, int st, int en) {",
            "        if(r < st or l > en) return NEUTRAL_ELEMENT;",
            "        else if(r >= en and l <= st) return tree[ind];",
            "        else{",
            "            if(st==en) return tree[ind];",
            "            int mid = (st+en)/2;",
            "            auto a = query(l,r,2*ind+1,st,mid);",
            "            auto b = query(l,r,2*ind+2,mid+1,en);",
            "            auto c = merge(a,b);",
            "            return c;",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "sgmt"
    },
    "fft": {
        "prefix": "fft",
        "body": [
            "mint2 proot = 3, iproot = mint2(1)/3;",
            "",
            "struct Polynomial {",
            "    vector<mint2> a;",
            "    Polynomial(int n) {",
            "        if((n&(n-1))) {",
            "            while ((n&(n-1))) {",
            "                n = (n&(n-1));",
            "            }",
            "            n *= 2;",
            "        }",
            "        a.resize(n);",
            "    }",
            "    Polynomial(vector<int> v, int n) {",
            "        proot = 3, iproot = mint2(1)/3;",
            "        if((n&(n-1))) {",
            "            while ((n&(n-1))) {",
            "                n = (n&(n-1));",
            "            }",
            "            n *= 2;",
            "        }",
            "        a.resize(n);",
            "        for(int i=0;i<v.size();i++) a[i] = v[i];",
            "    }",
            "    Polynomial(vector<int> v) {",
            "        Polynomial(v,v.size());",
            "    }",
            "    int size() {",
            "        return a.size();",
            "    }",
            "    mint2 &operator[](int x) {",
            "        return a[x];",
            "    }",
            "    void resize(int n) {",
            "        if((n&(n-1))) {",
            "            while ((n&(n-1))) {",
            "                n = (n&(n-1));",
            "            }",
            "            n *= 2;",
            "        }",
            "        a.resize(n,0);",
            "    }",
            "};",
            "",
            "void fft(Polynomial &p, bool invert = false) {",
            "    int n = p.size();",
            "    mint2 root = ((invert ? iproot : proot)^((mod2-1)/n));",
            "    for (int i = 1, j = 0; i < n; i++) {",
            "        int bit = (n >> 1);",
            "        while((j & bit)) {",
            "            j ^= bit;",
            "            bit >>= 1;",
            "        }",
            "        j ^= bit;",
            "        if (i < j) {",
            "            swap(p[i], p[j]);",
            "        }",
            "    }",
            "",
            "    for(int len = 2; len <= n; len <<= 1) {",
            "        mint2 eff_root = root;",
            "        for(int i=len;i<n;i<<=1) {",
            "            eff_root *= eff_root;",
            "        }",
            "        for(int i=0;i<n;i+=len) {",
            "            mint2 w = 1;",
            "            for(int j=0;j<len/2;j++) {",
            "                auto u = p[i+j], v = w*p[i+j+len/2];",
            "                p[i+j] = u+v, p[i+j+len/2] = u-v;",
            "                w *= eff_root;",
            "            }",
            "        }",
            "    }",
            "    if(invert) {",
            "        mint2 NInverse = mint2(1)/n;",
            "        for(int i=0;i<n;i++) p[i] *= NInverse;",
            "    }",
            "}",
            "",
            "",
            "Polynomial operator*(Polynomial p1, Polynomial p2) {",
            "    int n = p1.size()+p2.size();",
            "    p1.resize(n);p2.resize(n);",
            "    fft(p1);fft(p2);",
            "    for(int i=0;i<p1.size();i++) p1[i] *= p2[i];",
            "    fft(p1,true);",
            "    return p1;",
            "}"
        ],
        "description": "fft"
    }
}
