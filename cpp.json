{
    "boilerplate": {
        "prefix": "boilerplate",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "//#pragma GCC target (\"avx2\")",
            "//#pragma GCC optimize (\"O3\")",
            "//#pragma GCC optimize (\"unroll-loops\")",
            "",
            "// #include<bits/extc++.h>",
            "// using namespace __gnu_pbds;",
            "// template<typename T>",
            "// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "// template<typename T>",
            "// using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "// #define ook order_of_key",
            "// #define fbo find_by_order",
            "",
            "#define _green \"\\033[1;32m\"",
            "#define _yellow \"\\033[1;33m\"",
            "#define _orange \"\\033[1;34m\"",
            "#define _purple \"\\033[1;35m\"",
            "#define _blue \"\\033[1;36m\"",
            "#ifndef ONLINE_JUDGE",
            "#define trace(...) __f(__LINE__,_yellow,#__VA_ARGS__, __VA_ARGS__)",
            "#define Trace(color,...) __f(__LINE__,color,#__VA_ARGS__, __VA_ARGS__)",
            "#define wait(x) this_thread::sleep_for(chrono::milliseconds(x))",
            "#define seed 163",
            "#else",
            "#define trace(...) 42",
            "#define Trace(...) 167",
            "#define seed chrono::steady_clock::now().time_since_epoch().count()",
            "#define wait(x) 137",
            "#endif",
            "#define makegraph(adj, num)       \\",
            "    for (int i = 0; i < num; i++) \\",
            "    {                             \\",
            "        int u, v;                 \\",
            "        cin >> u >> v;            \\",
            "        adj[u].push_back(v);      \\",
            "        adj[v].push_back(u);      \\",
            "    }",
            "#define rep(i, k, n) for (int i = k; i < n; i++)",
            "#define rept(i, k, n) for (auto i = k; i != n; ++i)",
            "#define drep(i, k, n) for (int i = k; i >= n; i--)",
            "#define pb push_back",
            "#define mp make_pair",
            "#define ub upper_bound",
            "#define lb lower_bound",
            "#define all(a) a.begin(), a.end()",
            "#define endl '\\n'",
            "#define ll long long",
            "#define newint(...) int __VA_ARGS__;read(__VA_ARGS__);",
            "#define setbits(x) __builtin_popcount(x)",
            "#define setbitsll(x) __builtin_popcountll(x)",
            "#define Tj return",
            "#define out 0",
            "// #define segtree",
            "#ifdef segtree",
            "#define mid (st + en) / 2",
            "#define lidx 2 * ind + 1",
            "#define ridx 2 * ind + 2",
            "#define left st, mid, lidx, seg",
            "#define right mid + 1, en, ridx, seg",
            "#endif",
            "typedef vector<int> vi;",
            "typedef vector<pair<int, int>> vii;",
            "typedef pair<int, int> ii;",
            "typedef pair<int, pair<int, int>> iii;",
            "typedef map<int, int> mii;",
            "typedef map<char, int> mci;",
            "typedef set<int> si;",
            "typedef vector<vector<int>> vvi;",
            "typedef __int128_t xll;",
            "const int intmax = 2147483647;",
            "const int intmin = -2147483648;",
            "const int mod = 1000000007;",
            "const int mod2 = 998244353;",
            "mt19937 rng(seed);",
            "",
            "//IO operators for vectors, pairs, sets, maps and __int128",
            "template <typename T>istream &operator>>(istream &in, vector<T> &v);",
            "template <typename T>ostream &operator<<(ostream &ost, vector<T> v);",
            "template <typename T>ostream &operator<<(ostream &ost, set<T> s);",
            "template <typename T>ostream &operator<<(ostream &ost, multiset<T> s);",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, map<U,V> &m);",
            "template <typename U, typename V>istream &operator>>(istream &in, pair<U, V> &p);",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, pair<U, V> p);",
            "ostream &operator<<(ostream &ost, __int128_t x);",
            "istream &operator>>(istream &in, __int128_t &x);",
            "// Variadic IO",
            "template <typename... T>void read(T &...args);",
            "template <typename... T>void print(T... args);",
            "// Debug",
            "template <typename Arg1> void __f(int line, const char *color, const char* name, Arg1&& arg1);",
            "template <typename Arg1, typename... Args> void __f(int line, const char *color, const char* names, Arg1&& arg1, Args&&... args);",
            "",
            "void solve()",
            "{",
            "    $0",
            "}",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    int t=1;",
            "    cin >> t;",
            "    rep(var,1,t+1)",
            "        // cout << \"Case #\" << var << \": \",",
            "        solve();",
            "    Tj out;",
            "}",
            "",
            "//IO operators for vectors, pairs, sets, maps and __int128",
            "template <typename T>istream &operator>>(istream &in, vector<T> &v){for (auto &i : v)in >> i;return in;}",
            "template <typename T>ostream &operator<<(ostream &ost, vector<T> v){if(&ost == &cerr){cerr <<\"{\";int cnt = v.size();for(auto x:v){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:v)ost << i << \" \";return ost;}",
            "template <typename T>ostream &operator<<(ostream &ost, set<T> s){if(&ost == &cerr){cerr <<\"{\";int cnt = s.size();for(auto x:s){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:s)ost << i << \" \";return ost;}",
            "template <typename T>ostream &operator<<(ostream &ost, multiset<T> s){if(&ost == &cerr){cerr <<\"{\";int cnt = s.size();for(auto x:s){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:s)ost << i << \" \";return ost;}",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, map<U,V> &m){if(&ost == &cerr){cerr <<\"{\";int cnt = m.size();for(auto x:m){cerr << x; cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:m)ost << i;return ost;}",
            "template <typename U, typename V>istream &operator>>(istream &in, pair<U, V> &p){in>>p.first>>p.second;return in;}",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, pair<U, V> p){if (&ost == &cerr)ost << \"{\" << p.first << \": \" << p.second << \"}\";else ost << p.first << \" \" << p.second << \" \";return ost;}",
            "ostream &operator<<(ostream &ost, __int128_t x){string output = \"\";while(x)output += '0'+x%10, x /= 10;reverse(all(output)); ost << output;  return ost;}",
            "istream &operator>>(istream &in, __int128_t &x){x=0;string num;cin >> num;for(char c:num) x *= 10, x += c-'0';return in;}",
            "//Variadic IO",
            "template <typename... T>void read(T &...args){((cin >> args), ...);}",
            "template <typename... T>void print(T... args){((cout << args << \" \"), ...);cout << endl;}",
            "",
            "template <typename Arg1>",
            "void __f(int line, const char *color, const char* name, Arg1&& arg1){",
            "    cerr << \"\\033[2;37m(Ln \" << line << \")\\033[0m \" << color << name << \": \\033[0;37m\" << arg1 << \"\\033[0m \" << endl;",
            "}",
            "template <typename Arg1, typename... Args>",
            "void __f(int line, const char *color, const char* names, Arg1&& arg1, Args&&... args){",
            "    const char *comma = nullptr; int bracket = 0;",
            "    for(auto ptr = names; *ptr!='\\0'; ++ptr) {",
            "        if(*ptr == '(' or *ptr == '{' or *ptr == '[') bracket++;",
            "        else if(*ptr == ')' or *ptr == '}' or *ptr == ']') bracket--;",
            "        if(*ptr == ',' and bracket == 0) {",
            "            comma = ptr;",
            "            break;",
            "        }",
            "    }",
            "    cerr << \"\\033[2;37m(Ln \" << line << \")\\033[0m \" << color;",
            "    cerr.write(names, comma - names) << \": \\033[0;37m\" << arg1 << \"\\033[0m \" << endl;",
            "    __f(line,color, comma+1, args...);",
            "}",
            ""
        ],
        "description": "boilerplate"
    },
    "spf": {
        "prefix": "spf",
        "body": [
            "rep(i,0,${0:200001}) spf[i] = i;",
            "for(int i=2;i*i<${0:200001};i++){",
            "    if(spf[i] == i){",
            "        for(int j=i*i;j<${0:200001};j+=i){",
            "            if(spf[j]==j) spf[j] = i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "spf"
    },
    "binexp": {
        "prefix": "binexp",
        "body": [
            "long long binPow(long long a,long long b,long long modulo)",
            "{",
            "    long long prod = a;",
            "    long long ans = 1;",
            "    while(b){",
            "        if(b%2) ans = (ans*prod)%modulo;",
            "        b /= 2;",
            "        prod = (prod*prod)%modulo;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "binexp"
    },
    "Lowest Common Ancestor": {
        "prefix": "lca",
        "body": [
            "vvi parent;",
            "vi depth;",
            "int mxN;",
            "",
            "void dfs(int src, int par, vi *adj, int dep=0){",
            "    depth[src] = dep;",
            "    parent[src][0] = par;",
            "    for(int i=1;i<mxN;i++){",
            "        parent[src][i] = parent[parent[src][i-1]][i-1];",
            "    }",
            "    for(auto i:adj[src]){",
            "        if(i == par) continue;",
            "        dfs(i,src,adj,dep+1);",
            "    }",
            "}",
            "",
            "auto lca = [](int u, int v){",
            "    if(depth[u] < depth[v]) swap(u,v);",
            "    drep(i,mxN-1,0) if(depth[u]-(1<<i) >= depth[v]) u = parent[u][i];",
            "    if(u == v) return v;",
            "    drep(i,mxN-1,0) {",
            "        if(parent[u][i] != parent[v][i]){",
            "            u = parent[u][i];",
            "            v = parent[v][i];",
            "        }",
            "    }",
            "    return parent[u][0];",
            "};"
        ],
        "description": "lca"
    },
    "segmenttree": {
        "prefix": "segment",
        "body": [
            "void maketree($1 *arr, int st, int en, int ind , $2 *seg)",
            "{",
            "    if(st==en) seg[ind] = arr[st];",
            "    else{",
            "        maketree(arr,left);",
            "        maketree(arr,right);",
            "        seg[ind] = $3",
            "    }",
            "}",
            "",
            "void update($4, int st, int en, int ind, $2 *seg)",
            "{",
            "    if($6) return;",
            "    else if(st==en){",
            "        seg[ind] = $7",
            "    }",
            "    else{",
            "        update($5,left);",
            "        update($5,right);",
            "        seg[ind] = $3",
            "    }",
            "}",
            "",
            "$8 getans(int l, int r, int st, int en, int ind, $2 *seg)",
            "{",
            "    if(r < st or l > en) return $9;",
            "    else if(r >= en and l <= st) return seg[ind];",
            "    else{",
            "        if(st==en) return seg[ind];",
            "        auto a = getans(l,r,left);",
            "        auto b = getans(l,r,right);",
            "        auto c = $10",
            "        return c;",
            "    }",
            "}",
            ""
        ],
        "description": "SEgment tree'"
    },
    "sqrtdecomp": {
        "prefix": "sqrtdecomp",
        "body": [
            "const int blocksize = 447;",
            "",
            "struct Query {",
            "    int begin, end, order;",
            "    Query() {}",
            "    bool operator<(Query q) {",
            "        if(this->begin/blocksize == q.begin/blocksize) {",
            "            if((this->begin/blocksize)%2) ",
            "                return this->end > q.end;",
            "            else",
            "                return this->end < q.end;",
            "        } else {",
            "            return this->begin/blocksize < q.begin/blocksize;",
            "        }",
            "    }",
            "};",
            "",
            "void solve()",
            "{",
            "    int n,q;",
            "    cin >> n >> q; ",
            "    vi v(n);",
            "    cin >> v;",
            "    vector<Query> query(q);",
            "    vector<int> answer(q);",
            "    rep(i,0,q) {",
            "        cin >> query[i].begin >> query[i].end;",
            "        query[i].begin--, query[i].end--;",
            "        query[i].order = i;",
            "    }",
            "",
            "    sort(all(query));",
            "",
            "    int l = query[0].begin, r = query[0].begin;",
            "    int ans = 0;",
            "",
            "    for(int i=0;i<q;i++){",
            "        while(r < query[i].end) {",
            "            r++;",
            "        }",
            "        while(l > query[i].begin) {",
            "            l--;",
            "        }",
            "        while(l < query[i].begin) {",
            "            l++;",
            "        }",
            "        while(r > query[i].end) {",
            "            r--;",
            "        }",
            "        answer[query[i].order] = ans;",
            "    }",
            "",
            "    for(auto i:answer) cout << i << endl;",
            "}"
        ],
        "description": "sqrtdecomp"
    },
    "Basic trie": {
        "prefix": "basictrie",
        "body": [
            "struct trieNode{",
            "    char ch;",
            "    int ending;",
            "    map<char, trieNode*> pointers;",
            "    trieNode* parent;",
            "    trieNode(){",
            "        ch = '\\0';",
            "        ending = 0;",
            "        pointers.clear();",
            "        parent = nullptr;",
            "    }",
            "};",
            "",
            "class trie{",
            "    public:",
            "    trieNode *root;",
            "    trie()",
            "    {",
            "        root = new trieNode;",
            "        root->ending = 0;",
            "        root->ch = '\\0';",
            "        root->parent = nullptr;",
            "    }",
            "    int count(string s){",
            "        trieNode *ptr = root;",
            "        int p = 0;",
            "        while(p < s.size() and ptr->pointers.find(s[p])!=ptr->pointers.end()){",
            "            ptr = ptr->pointers[s[p]];",
            "            p++;",
            "        }",
            "        if(p < s.size()) return 0;",
            "        else return ptr->ending;",
            "    }",
            "    void insert(string s){",
            "        trieNode *ptr = root;",
            "        for(int i=0;i<s.size();i++){",
            "            if(ptr->pointers.find(s[i]) == ptr->pointers.end())",
            "                ptr->pointers[s[i]] = new trieNode,",
            "                ptr->pointers[s[i]]->ch = s[i];",
            "                ptr->pointers[s[i]]->parent = ptr;",
            "                ptr = ptr->pointers[s[i]];",
            "        }",
            "        ptr->ending++;",
            "    }",
            "",
            "    void remove(string s){",
            "        if(count(s) == 0) return;",
            "        trieNode *ptr = root;",
            "        for(char c:s){",
            "            ptr = ptr->pointers[c];",
            "        }",
            "        ptr->ending--;",
            "        while(ptr->parent != nullptr){",
            "            char c;",
            "            if(ptr->pointers.empty() and ptr->ending == 0){",
            "                c = ptr->ch;",
            "                ptr = ptr->parent;",
            "                delete ptr->pointers[c];",
            "                ptr->pointers[c] = nullptr;",
            "                ptr->pointers.erase(c);",
            "            }",
            "            else break;",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "Basic implementation of Trie"
    },
    "modular": {
        "prefix": "modular",
        "body": [
            "long long binExpp(long long a,long long b,long long modulo)",
            "{",
            "    long long prod = a;",
            "    long long ans = 1;",
            "    while(b){",
            "        if(b%2) ans = (ans*prod)%modulo;",
            "        b /= 2;",
            "        prod = (prod*prod)%modulo;",
            "    }",
            "    return ans;",
            "}",
            "",
            "template<const int mod>",
            "class Mint{",
            "    long long val;",
            "",
            "    public: ",
            "    Mint(long long _val){",
            "        val = (_val%mod+mod)%mod;",
            "    }",
            "    Mint(){",
            "        val = 0;",
            "    }",
            "    Mint operator+(Mint b){",
            "        return Mint((this->val+b.val)%mod);",
            "    }",
            "    Mint operator-(Mint b){",
            "        return Mint(this->val-b.val+mod)%mod;",
            "    }",
            "    Mint operator*(Mint b){",
            "        return Mint((this->val*b.val)%mod);",
            "    }",
            "    Mint operator/(Mint b){",
            "        return (Mint(binExpp(b(), mod-2, mod))*(*this));",
            "    }",
            "    long long &operator()(){",
            "        return val;",
            "    }",
            "    Mint operator+=(Mint b){",
            "        return *this = *this+b;",
            "    }",
            "    Mint operator-=(Mint b){",
            "        return *this = *this-b;",
            "    }",
            "    Mint operator*=(Mint b){",
            "        return *this = *this*b;",
            "    }",
            "    Mint operator/=(Mint b){",
            "        return *this = *this/b;",
            "    }",
            "    int operator%(int modulo){",
            "        return val%modulo;",
            "    }",
            "    int operator%(Mint modulo){",
            "        return val%(modulo());",
            "    }",
            "    Mint operator++(){",
            "        return *this = *this+Mint(1);",
            "    }",
            "    Mint operator= (int x){",
            "        return (*this).val = (x%mod+mod)%mod;",
            "    }",
            "    Mint operator^(Mint pow){",
            "        return Mint(binExpp((*this)(),pow(),mod));",
            "    }",
            "};",
            "template<const int mod>",
            "istream &operator>>(istream &in, Mint<mod> &a)",
            "{",
            "    return in >> a();",
            "}",
            "template<const int mod>",
            "ostream &operator<<(ostream &outt, Mint<mod> a)",
            "{",
            "    return outt<<a();",
            "}",
            "template<const int mod>",
            "Mint<mod> operator+(int mul, Mint<mod> m){",
            "    return m+mul;",
            "}",
            "template<const int mod>",
            "Mint<mod> operator*(int mul, Mint<mod> m){",
            "    return m*Mint<mod>(mul);",
            "}",
            "template<const int mod>",
            "Mint<mod> operator-(int sub, Mint<mod> m){",
            "    return Mint<mod>(sub)-m;",
            "}",
            "template<const int mod>",
            "Mint<mod> operator/(int div, Mint<mod> m){",
            "    return Mint<mod>(div)/m;",
            "}",
            "template<const int mod>",
            "Mint<mod> operator^(int base, Mint<mod> m){",
            "    return Mint<mod>(base)^m;",
            "}",
            "",
            "",
            "template<const int mod>",
            "vector<Mint<mod>> Factorial(int n)",
            "{",
            "    vector<Mint<mod>> fact(n+1);",
            "    fact[0] = 1;",
            "    for(int i=1;i<=n;i++) fact[i] = i*fact[i-1];",
            "    return fact;",
            "}",
            "",
            "using mint = Mint<1000000007>;",
            "using mint2 = Mint<998244353>;",
            "using vmi = vector<mint>;",
            "mint operator\"\" _m(unsigned long long x) {",
            "    return mint(x);",
            "}",
            "mint2 operator\"\" _m2(unsigned long long x) {",
            "    return mint2(x);",
            "}"
        ],
        "description": "modular"
    },
    "randomstuff": {
        "prefix": "randomstuff",
        "body": [
            "",
            "#define rnd(x, y) uniform_int_distribution<long long int>(x, y)(rng)",
            "inline int randomIndex(int maxInd) {",
            "    return abs(int(rng()))%maxInd; ",
            "}",
            "",
            "",
            "template<typename T>",
            "inline void randomShuffle(vector<T> &v){",
            "    for(int i=0;i<v.size();i++){",
            "        int j = randomIndex(i+1);",
            "        swap(v[j],v[i]);",
            "    }",
            "}",
            "",
            "template<typename T>",
            "inline void randomShuffle(T *arr, int sz){",
            "    for(int i=0;i<sz;i++){",
            "        int j = randomIndex(i+1);",
            "        swap(arr[j],arr[i]);",
            "    }",
            "}"
        ],
        "description": "randomstuff"
    },
    "hashing": {
        "prefix": "hashing",
        "body": [
            "constexpr int largeprimes[] = {1000000007,1000000009,1000000021,1000000033,1000000087,1000000093,1000000097,1000000103,1000000123,1000000181,1000000207,1000000223,1000000241};",
            "template<const int mod1, const int mod2, const int base = 31>",
            "struct Hash{",
            "    private:",
            "    long long baseInverse1, baseInverse2;",
            "    long long lenPow1, lenPow2;",
            "    public:",
            "    long long hash1, hash2;",
            "    int length;",
            "    Hash(string s){",
            "        baseInverse1 = binPow(base,mod1-2,mod1);",
            "        baseInverse2 = binPow(base,mod2-2,mod2);",
            "        hash1 = hash2 = length = 0;",
            "        for(auto i:s){",
            "            hash1 *= (base);",
            "            hash2 *= (base);",
            "            hash1 += (i-'a'+1);",
            "            hash2 += (i-'a'+1);",
            "            hash1 %= mod1;",
            "            hash2 %= mod2;",
            "            length++;",
            "        }",
            "        lenPow1 = binPow(base,length,mod1);",
            "        lenPow2 = binPow(base,length,mod2);",
            "    }",
            "    Hash(){",
            "        baseInverse1 = binPow(base,mod1-2,mod1);",
            "        baseInverse2 = binPow(base,mod2-2,mod2);",
            "        lenPow1 = lenPow2 = 1;",
            "        hash1 = hash2 = length = 0;",
            "    }",
            "    bool operator==(const Hash h){",
            "        return (this->hash1==h.hash1 and this->hash2==h.hash2 and this->length == h.length);",
            "    }",
            "    void push_back(char c){",
            "        hash1 *= (base);",
            "        hash2 *= (base);",
            "        hash1 += (c-'a'+1);",
            "        hash2 += (c-'a'+1);",
            "        hash1 %= mod1;",
            "        hash2 %= mod2;",
            "        lenPow1 = (lenPow1*base)%mod1;",
            "        lenPow2 = (lenPow2*base)%mod2;",
            "        length++;",
            "    }",
            "    void push_front(char c){",
            "        hash1 += (c-'a'+1)*lenPow1;",
            "        hash1 %= mod1;",
            "        hash2 += (c-'a'+1)*lenPow2;",
            "        hash2 %= mod2;",
            "        lenPow1 = (lenPow1*base)%mod1;",
            "        lenPow2 = (lenPow2*base)%mod2;",
            "        length++;",
            "    }",
            "    void pop_back(char c){",
            "        hash1 -= (c-'a'+1);",
            "        hash1 *= baseInverse1;",
            "        hash1 %= mod1;",
            "        hash2 -= (c-'a'+1);",
            "        hash2 *= baseInverse2;",
            "        hash2 %= mod2;",
            "        lenPow1 = (lenPow1*baseInverse1)%mod1;",
            "        lenPow2 = (lenPow2*baseInverse2)%mod2;",
            "        length--;",
            "    }",
            "    void pop_front(char c){",
            "        lenPow1 = (lenPow1*baseInverse1)%mod1;",
            "        lenPow2 = (lenPow2*baseInverse2)%mod2;",
            "        hash1 -= ((c-'a'+1)*lenPow1)%mod1;",
            "        hash1 %= mod1;",
            "        hash1 += mod1;",
            "        hash1 %= mod1;",
            "        hash2 -= ((c-'a'+1)*lenPow2)%mod2;",
            "        hash2 %= mod2;",
            "        hash2 += mod2;",
            "        hash2 %= mod2;",
            "        length--;",
            "    }",
            "};",
            "",
            "template<const int m1, const int m2>",
            "ostream &operator<<(ostream &ost, Hash<m1,m2> h){",
            "    ost << \"{\" << h.hash1 << \", \" << h.hash2 << \"}\\n\";",
            "    return ost;",
            "}",
            "",
            "template<const int m1, const int m2>",
            "bool operator<(Hash<m1,m2> h1, Hash<m1,m2> h2){",
            "    return make_pair(h1.hash1, make_pair(h1.hash2,h1.length)) < make_pair(h2.hash1, make_pair(h2.hash2,h2.length));",
            "}",
            ""
        ],
        "description": "hashing"
    },
    "Alternate segment tree": {
        "prefix": "altsegment",
        "body": [
            "template<typename T>",
            "struct Merge{",
            "    T operator()(T &a, T &b){",
            "        ",
            "    }",
            "};",
            "",
            "template<typename T>",
            "struct update{",
            "    T operator()(T a, T b){",
            "        ",
            "    }",
            "};",
            "",
            "template<typename T, typename _merge, typename _update>",
            "struct segment_tree",
            "{",
            "    int size;",
            "    T *seg;",
            "    T neutral_element;",
            "    _merge __merge;",
            "    _update __update;",
            "    template<typename U>",
            "    void make_tree(U init, int st, int en, int index){",
            "        if(st == en) seg[index] = vi({init[st]});",
            "        else{",
            "            make_tree(init,st, (st+en)/2 ,2*index+1);",
            "            make_tree(init,(st+en)/2+1,en,2*index+2);",
            "            seg[index] = __merge(seg[2*index+1],seg[2*index+2]);",
            "        }",
            "    }",
            "    void make_tree(int st, int en, int index){",
            "        if(st == en) seg[index] = neutral_element;",
            "        else{",
            "            make_tree(st, (st+en)/2 ,2*index+1);",
            "            make_tree((st+en)/2+1,en,2*index+2);",
            "            seg[index] = __merge(seg[2*index+1],seg[2*index+2]);",
            "        }",
            "    }",
            "",
            "    template<typename U>",
            "    segment_tree(U init, int _size,  T _neutral_element){",
            "        size = _size;",
            "        neutral_element = _neutral_element;",
            "        seg = new T[4*size];",
            "        make_tree(init,0,size-1,0);",
            "    }",
            "    segment_tree(int _size,  T _neutral_element){",
            "        size = _size;",
            "        neutral_element = _neutral_element;",
            "        seg = new T[4*size];",
            "        make_tree(0,size-1,0);",
            "    }",
            "",
            "    void update(int pos, int val, int st, int en, int index)",
            "    {",
            "        if(pos > en or pos < st) return;",
            "        else if(st==en){",
            "            seg[index] = __update(seg[index],val);",
            "        }",
            "        else{",
            "            update(pos,val,st, (st+en)/2 ,2*index+1);",
            "            update(pos,val,(st+en)/2+1,en,2*index+2);",
            "            seg[index] = __merge(seg[2*index+1],seg[2*index+2]);",
            "        }",
            "    }",
            "",
            "    void update(int pos, int val){",
            "        update(pos,val,0,size-1,0);",
            "    }",
            "",
            "    T query(int l, int r){",
            "        return query(l,r,0,size-1,0);",
            "    }",
            "    T query(int l, int r, int st, int en, int index){",
            "        if(r < st or l > en) return neutral_element;",
            "        else if(r >= en and l <= st) return seg[index];",
            "        else{",
            "            if(st==en) return seg[index];",
            "            auto a = query(l,r,st, (st+en)/2 ,2*index+1);",
            "            auto b = query(l,r,(st+en)/2+1,en,2*index+2);",
            "            auto c = __merge(a,b);",
            "            return c;",
            "        }",
            "    }",
            "};",
            "",
            "template<typename T>",
            "using segTree = segment_tree<T, Merge<T>,update<T>>;",
            ""
        ],
        "description": "alternate segment tree"
    },
    "matrix": {
        "prefix": "matrix",
        "body": [
            "template<long long modulo>",
            "struct matrix{",
            "\tvector<vector<long long>> mat;",
            "\tint row, col;",
            "\tmatrix(long long _row, long long _col){",
            "\t\trow = _row, col = _col;",
            "\t\tmat.assign(row, vector<long long>(col,0));",
            "\t}",
            "\tvector<long long> &operator[](long long r){",
            "\t\tif(r >= mat.size()) throw;",
            "\t\treturn mat[r];",
            "\t}",
            "",
            "\tmatrix operator*(matrix &m){",
            "\t\tif(m.row != this->col){",
            "\t\t\tthrow;",
            "\t\t}",
            "\t\tmatrix res(this->row, m.col);",
            "\t\tfor(int i=0;i<this->row;i++){",
            "\t\t\tfor(int j=0;j<m.col;j++){",
            "\t\t\t\tfor(int k=0;k<m.row;k++){",
            "\t\t\t\t\tres[i][j] = (res[i][j] + (((*this)[i][k])*m[k][j])%modulo)%modulo;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "\tvector<vector<long long>>::iterator begin(){",
            "\t\treturn mat.begin();",
            "\t}",
            "",
            "\tvector<vector<long long>>::iterator end(){",
            "\t\treturn mat.end();",
            "\t}",
            "",
            "\tvoid operator=(matrix m){",
            "\t\tthis->mat = m.mat;",
            "\t\tthis->row = m.row;",
            "\t\tthis->col = m.col;",
            "\t}",
            "};",
            "",
            "template<long long modulo>",
            "matrix<modulo> Identity(int sz){",
            "\tmatrix<modulo> res(sz,sz);",
            "\tfor(int i=0;i<sz;i++){",
            "\t\tres[i][i] = 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "template<long long modulo> ostream &operator<<(ostream &ost, matrix<modulo> m){for(auto &i:m){for(auto &j:i) ost << j << \" \";ost << endl;}return ost;}",
            "template<long long modulo> istream &operator>>(istream &ist, matrix<modulo> &m){for(auto &i:m)for(auto &j:i) ist>>j;return ist;}",
            "",
            "",
            "template<long long modulo>",
            "matrix<modulo> matrixExpo(matrix<modulo> &m, long long power){",
            "\tif(m.row != m.col) throw;",
            "\tmatrix<modulo> res = Identity<modulo>(m.row);",
            "\tauto prod = m;",
            "\twhile(power){",
            "\t\tif((power&1)) res = res*prod;",
            "\t\tprod = (prod*prod);",
            "\t\tpower /= 2;",
            "\t}",
            "\treturn res;",
            "}",
            ""
        ],
        "description": "matrix"
    },
    "doublematrix": {
        "prefix": "doublematrix",
        "body": [
            "",
            "struct matrix{",
            "\tvector<vector<double>> mat;",
            "\tint row, col;",
            "\tmatrix(long long _row, long long _col){",
            "\t\trow = _row, col = _col;",
            "\t\tmat.assign(row, vector<double>(col,0));",
            "\t}",
            "\tvector<double> &operator[](long long r){",
            "\t\tif(r >= mat.size()) throw;",
            "\t\treturn mat[r];",
            "\t}",
            "",
            "\tmatrix operator*(matrix &m){",
            "\t\tif(m.row != this->col){",
            "\t\t\tthrow;",
            "\t\t}",
            "\t\tmatrix res(this->row, m.col);",
            "\t\tfor(int i=0;i<this->row;i++){",
            "\t\t\tfor(int j=0;j<m.col;j++){",
            "\t\t\t\tfor(int k=0;k<m.row;k++){",
            "\t\t\t\t\tres[i][j] += (((*this)[i][k])*m[k][j]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "\tvector<vector<double>>::iterator begin(){",
            "\t\treturn mat.begin();",
            "\t}",
            "",
            "\tvector<vector<double>>::iterator end(){",
            "\t\treturn mat.end();",
            "\t}",
            "",
            "\tvoid operator=(matrix m){",
            "\t\tthis->mat = m.mat;",
            "\t\tthis->row = m.row;",
            "\t\tthis->col = m.col;",
            "\t}",
            "};",
            "",
            "matrix Identity(int sz){",
            "\tmatrix res(sz,sz);",
            "\tfor(int i=0;i<sz;i++){",
            "\t\tres[i][i] = 1;",
            "\t}",
            "\treturn res;",
            "}",
            "ostream &operator<<(ostream &ost, matrix m){for(auto &i:m){for(auto &j:i) ost << j << \" \";ost << endl;}return ost;}",
            "istream &operator>>(istream &ist, matrix &m){for(auto &i:m)for(auto &j:i) ist>>j;return ist;}",
            "",
            "",
            "matrix matrixExpo(matrix &m, long long power){",
            "\tif(m.row != m.col) throw;",
            "\tmatrix res = Identity(m.row);",
            "\tauto prod = m;",
            "\twhile(power){",
            "\t\tif((power&1)) res = res*prod;",
            "\t\tprod = (prod*prod);",
            "\t\tpower /= 2;",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "doublematrix"
    },
    "dsuint": {
        "prefix": "dsuint",
        "body": [
            "class DSU {",
            "    vector<int> root;",
            "    vector<int> sz;",
            "public:",
            "    int find(int x) {",
            "        if (root[x] != x) root[x] = find(root[x]);",
            "        return root[x];",
            "    }",
            "    void join(int x, int y) {",
            "        x = find(x);",
            "        y = find(y);",
            "        if (x == y) return;",
            "        if (sz[x] > sz[y]) swap(x, y);",
            "        root[x] = y;",
            "        sz[y] += sz[x];",
            "        sz[x] = 0;",
            "    }",
            "    DSU(int n) {",
            "        root = vector<int>(n+1);",
            "        sz = vector<int>(n+1,1);",
            "        iota(root.begin(), root.end(), 0);",
            "    }",
            "};"
        ],
        "description": "dsuint"
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "",
            "template<typename T>",
            "class DSU {",
            "    map<T,T> root;",
            "    map<T,int> sz;",
            "public:",
            "    DSU() {}",
            "    void init(T val) {",
            "        if(!root.count(val)) {",
            "            root[val] = val;",
            "            sz[val] = 1;",
            "        }",
            "    }",
            "",
            "    T find(T val, bool create = true) {",
            "        if(!root.count(val)) {",
            "            if(!create) return T();",
            "            init(val);",
            "            return val;",
            "        }",
            "        if(root[val] == val) return val;",
            "        return root[val] = find(root[val], create);",
            "    }",
            "",
            "    void join(T a, T b, bool create = true) {",
            "        a = find(a,create);",
            "        b = find(b,create);",
            "        if(a == b) return;",
            "        if(sz[a] > sz[b]) {",
            "            swap(a, b);",
            "        }",
            "        root[b] = a;",
            "        sz[a] += sz[b];",
            "        sz[a] = 0;",
            "    }",
            "};",
            ""
        ],
        "description": "dsu"
    },
    "HLD": {
        "prefix": "HLD",
        "body": [
            "#define func max",
            "",
            "vvi parent;",
            "vi depth, label, toc, subsize, seg, vals;",
            "int mxN = 20;",
            "",
            "void dfsone(int src, int par, vi *adj, int dep=0){",
            "    depth[src] = dep;",
            "    parent[src][0] = par;",
            "    subsize[src] = 1;",
            "    for(int i=1;i<mxN;i++){",
            "        parent[src][i] = parent[parent[src][i-1]][i-1];",
            "    }",
            "    for(auto i:adj[src]){",
            "        if(i == par) continue;",
            "        dfsone(i,src,adj,dep+1);",
            "        subsize[src] += subsize[i];",
            "    }",
            "}",
            "",
            "int timer = 0;",
            "",
            "void dfstwo(int src, int parent, vi *adj, bool heavy){",
            "    label[src] = timer++;",
            "    toc[src] = ((heavy)?toc[parent]:src);",
            "    int mx=0,pos=-1;",
            "    for(auto i:adj[src]) {",
            "        if(i == parent) continue;",
            "        if(subsize[i] > mx){",
            "            mx = subsize[i];",
            "            pos = i;",
            "        }",
            "    }",
            "    if(pos != -1)dfstwo(pos,src,adj,1);",
            "    for(auto i:adj[src]) {",
            "        if(i == parent) continue;",
            "        if(i == pos) continue;",
            "        else {",
            "            dfstwo(i,src,adj,0);",
            "        }",
            "    }",
            "}",
            "",
            "void update(int pos, int val, int st, int en, int ind, vi &seg)",
            "{",
            "    if(pos > en or pos < st) return;",
            "    else if(st==en){",
            "        seg[ind] = val;",
            "    }",
            "    else{",
            "        update(pos,val,left);",
            "        update(pos,val,right);",
            "        seg[ind] = func(seg[ridx], seg[lidx]);",
            "    }",
            "}",
            "",
            "int getans(int l, int r, int st, int en, int ind, vi &seg)",
            "{",
            "    if(l > r) swap(l,r);",
            "    if(r < st or l > en) return intmin;",
            "    else if(r >= en and l <= st) return seg[ind];",
            "    else{",
            "        if(st==en) return seg[ind];",
            "        auto a = getans(l,r,left);",
            "        auto b = getans(l,r,right);",
            "        auto c = func(a,b);",
            "        return c;",
            "    }",
            "}",
            "",
            "",
            "auto lca = [](int u, int v){",
            "    if(depth[u] < depth[v]) swap(u,v);",
            "    drep(i,mxN-1,0) if(depth[u]-(1<<i) >= depth[v]) u = parent[u][i];",
            "    if(u == v) return v;",
            "    drep(i,mxN-1,0) {",
            "        if(parent[u][i] != parent[v][i]){",
            "            u = parent[u][i];",
            "            v = parent[v][i];",
            "        }",
            "    }",
            "    return parent[u][0];",
            "};",
            "",
            "void solve()",
            "{",
            "    int n, q;",
            "    cin >> n >> q;",
            "    vi adj[n+1];",
            "    vals.resize(n+1);",
            "    rep(i,1,n+1) cin >> vals[i];",
            "    makegraph(adj,n-1);",
            "    parent.assign(n+1, vi(mxN, 0));",
            "    depth.resize(n+1);",
            "    label.resize(n+1);",
            "    toc.resize(n+1);",
            "    subsize.resize(n+1);",
            "    seg.resize(4*n);",
            "    dfsone(1,0,adj);",
            "    dfstwo(1,0,adj,false);",
            "    trace(label);trace(vals);trace(depth);trace(subsize);",
            "    rep(i,1,n+1) {",
            "        update(label[i],vals[i],0,n-1,0,seg);",
            "    }",
            "    while(q--) {",
            "        newint(type,x,y);",
            "        if(type == 1) {",
            "            update(label[x],y,0,n-1,0,seg);",
            "            vals[x] = y;",
            "        } else {",
            "            int l = lca(x,y);",
            "            trace(x,y,l);",
            "            int ans1 = vals[x], ans2 = vals[y];",
            "            int node1 = x, node2 = y;",
            "            while(node1 != l) {",
            "                if(toc[node1] == node1) {",
            "                    node1 = parent[node1][0];",
            "                    ans1 = func(ans1, vals[node1]);",
            "                }",
            "                else if(depth[toc[node1]] >= depth[l]) {",
            "                    ans1 = func(ans1, getans(label[toc[node1]],label[node1],0,n-1,0,seg));",
            "                    node1 = toc[node1];",
            "                } else {",
            "                    ans1 = func(ans1, getans(label[l], label[node1], 0, n-1, 0, seg));",
            "                    node1 = l;",
            "                }",
            "            }",
            "            while(node2 != l) {",
            "                if(toc[node2] == node2) {",
            "                    node2 = parent[node2][0];",
            "                    ans2 = func(ans2, vals[node2]);",
            "                }",
            "                else if(depth[toc[node2]] >= depth[l]) {",
            "                    ans2 = func(ans2, getans(label[toc[node2]],label[node2],0,n-1,0,seg));",
            "                    node2 = toc[node2];",
            "                } else {",
            "                    ans2 = func(ans2, getans(label[l], label[node2],0,n-1,0,seg));",
            "                    node2 = l;",
            "                }",
            "            }",
            "            cout << func(ans1,ans2) << endl;",
            "        }",
            "    }",
            "    cout << endl;",
            "}"
        ],
        "description": "HLD"
    },
    "ezbs": {
        "prefix": "ezbs",
        "body": [
            "template<typename T, T (*func)(int)>",
            "class range {",
            "    int startIndex, endIndex;",
            "    public:",
            "    class iterator {",
            "        int index;",
            "        public:",
            "        using iterator_category = std::random_access_iterator_tag;",
            "        using difference_type   = std::ptrdiff_t;",
            "        using value_type        = T;",
            "        using pointer           = T*;",
            "        using reference         = T;",
            "        iterator(int idx) {",
            "            index = idx;",
            "        }",
            "        T operator*() const {",
            "            return func(index);",
            "        }",
            "        iterator &operator++(){",
            "            this->index++;",
            "            return *this;",
            "        }",
            "        iterator &operator--(){",
            "            this->index--;",
            "            return *this;",
            "        }",
            "        iterator operator++(int32_t) {",
            "            iterator tmp = *this;",
            "            ++(*this);",
            "            return tmp;",
            "        }",
            "        iterator operator--(int32_t) {",
            "            iterator tmp = *this;",
            "            --(*this);",
            "            return tmp;",
            "        }",
            "        iterator operator+(int x) {",
            "            return iterator(index+x);",
            "        }",
            "        iterator operator+=(int x) {",
            "            this->index += x;",
            "            return *this;",
            "        }",
            "        iterator operator-(int x) {",
            "            return iterator(index+x);",
            "        }",
            "        difference_type operator-(const iterator &a) {",
            "            return this->index-a.index;",
            "        }",
            "        iterator operator-=(int x) {",
            "            this->index -= x;",
            "            return *this;",
            "        }",
            "        int position() {",
            "            return index;",
            "        }",
            "        difference_type distance(iterator a, iterator b) {",
            "            return b.index-a.index;",
            "        }",
            "        friend bool operator!=(const iterator &a, const iterator &b) {",
            "            return a.index != b.index;",
            "        }",
            "        friend bool operator==(const iterator &a, const iterator &b) {",
            "            return a.index == b.index;",
            "        }",
            "    };",
            "    range(int st, int en) {",
            "        startIndex = st;",
            "        endIndex = en;",
            "    }",
            " ",
            "    iterator begin() {",
            "        return iterator(startIndex);",
            "    }",
            " ",
            "    iterator end() {",
            "        return iterator(endIndex);",
            "    }",
            "};"
        ],
        "description": "ezbs"
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "#define time(function_name, ...) {Timer t(#function_name); function_name(__VA_ARGS__);}",
            "#define Time(var,function_name,...){Timer t(#function_name); var = function_name(__VA_ARGS__);}",
            "class Timer {",
            "    string name;",
            "    decltype(chrono::high_resolution_clock::now()) startTime, endTime;",
            "    public:",
            "    #ifndef ONlINE_JUDGE",
            "    Timer(string s) {",
            "        name = s;",
            "        startTime = chrono::high_resolution_clock::now();",
            "    }",
            "    ~Timer() {",
            "        endTime = chrono::high_resolution_clock::now();",
            "        cerr << name << \" took \" << chrono::duration_cast<chrono::milliseconds>(endTime-startTime).count() << \"ms\" << endl;",
            "    }",
            "    #else",
            "    Timer(string s) {}",
            "    #endif",
            "};"
        ],
        "description": "timer"
    },
    "stringmatching": {
        "prefix": "stringmatching",
        "body": [
            "",
            "struct _contains_ {string_view _;_contains_(){}};",
            "_contains_ operator<(string s, _contains_ C) {_contains_ c;c._ = s;return c;}",
            "bool operator>(_contains_ c, string s){const int p = 31; const int m = 1e9 + 9;int S = s.size(), T = c._.size();vector<long long> p_pow(max(S, T)); p_pow[0] = 1; for (int i = 1; i < (int)p_pow.size(); i++) {p_pow[i] = (p_pow[i-1] * p) % m;}vector<long long> h(T + 1, 0); for (int i = 0; i < T; i++) {h[i+1] = (h[i] + (c._[i] - 'a' + 1) * p_pow[i]) % m;}long long h_s = 0; for (int i = 0; i < S; i++) {h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m;} for (int i = 0; i + S - 1 < T; i++) { long long cur_h = (h[i+S] + m - h[i]) % m; if (cur_h == h_s * p_pow[i] % m){return true;}}return false;}",
            "#define has <_contains_()>",
            "",
            ""
        ],
        "description": "stringmatching"
    },
    "orderedms": {
        "prefix": "orderedms",
        "body": [
            "struct ordered_multiset {",
            "    struct Node {",
            "        int m_value;",
            "        pair<int,int> m_range;",
            "        Node *m_left, *m_right;",
            "        inline Node(int left, int right) {",
            "            m_range = {left, right};",
            "            m_left = m_right = nullptr;",
            "            m_value = 0;",
            "        }",
            "        inline int value() {",
            "            return m_value;",
            "        }",
            "        inline Node *left() {",
            "            return m_left;",
            "        }",
            "        inline Node *right() {",
            "            return m_right;",
            "        }",
            "        inline pair<int,int> range() {",
            "            return m_range;",
            "        }",
            "        ~Node() {",
            "            delete m_left;",
            "            delete m_right;",
            "        }",
            "    };",
            "    Node *m_root;",
            "    void segtree_update(int pos, int val, Node *root) {",
            "        if(root->range() == make_pair(pos, pos)) {",
            "            root->m_value += val;",
            "            return;",
            "        }",
            "        if(root->range().first == root->range().second) return;",
            "        int mid = (root->range().first + root->range().second)/2;",
            "        if(not root->left()) {",
            "            root->m_left = new Node(root->range().first, mid);",
            "            root->m_right = new Node(mid+1, root->range().second);",
            "        }",
            "        if(pos > mid) segtree_update(pos, val, root->m_right);",
            "        else segtree_update(pos, val, root->m_left);",
            "        root->m_value = root->m_left->m_value + root->m_right->m_value;",
            "    }",
            "    int segtree_query(int l, int r, Node *root) {",
            "        if(l <= root->range().first and root->range().second <= r) return root->value();",
            "        if(root->range().first > r or root->range().second < l) return 0;",
            "        if(not root->left()) {",
            "            int mid = (root->range().first + root->range().second)/2;",
            "            root->m_left = new Node(root->range().first, mid);",
            "            root->m_right = new Node(mid+1, root->range().second);",
            "        }",
            "        return segtree_query(l, r, root->m_left) + segtree_query(l, r, root->m_right);",
            "    }",
            "    inline ordered_multiset(int l_bount=0, int u_bound=1000000000) {",
            "        m_root = new Node(l_bount, u_bound);",
            "    }",
            "",
            "    inline bool contains(int key) {",
            "        return (segtree_query(key, key, m_root) > 0);",
            "    }",
            "",
            "    inline int count(int key) {",
            "        return segtree_query(key, key, m_root);",
            "    }",
            "",
            "    inline void insert(int key) {",
            "        segtree_update(key, 1, m_root);",
            "    }",
            "    ",
            "    inline int size() {",
            "        return m_root->value();",
            "    }",
            "",
            "    //Removes one copy of the key",
            "    inline void remove(int key) {",
            "        segtree_update(key, -1, m_root);",
            "    }",
            "",
            "    //Removes all copies of the key",
            "    inline void erase(int key) {",
            "        segtree_update(key, -segtree_query(key,key,m_root), m_root);",
            "    }",
            "    inline int find_by_order(size_t order) {",
            "        if(order >= size()) return m_root->range().second+1;",
            "        Node *cur = m_root;",
            "        while(cur->left()) {",
            "            int mid = (cur->range().first + cur->range().second)/2;",
            "            if(order < cur->left()->value()) cur = cur->left();",
            "            else {",
            "                order -= cur->left()->value();",
            "                cur = cur->right();",
            "            }",
            "        }",
            "        return cur->range().first;",
            "    }",
            "    inline int order_of_key(int key) {",
            "        return segtree_query(m_root->range().first, key-1, m_root);",
            "    }",
            "    vector<int> elements() {",
            "        vector<int> v;",
            "        stack<Node *> s;",
            "        s.push(m_root);",
            "        while(!s.empty()) {",
            "            Node *cur = s.top();",
            "            s.pop();",
            "            if(cur->left() and cur->left()->value()) s.push(cur->left());",
            "            if(cur->right() and cur->right()->value()) s.push(cur->right());",
            "            if(cur->range().first == cur->range().second) {",
            "                for(int i=0;i<cur->value();i++) v.push_back(cur->range().first);",
            "            }",
            "        }",
            "        reverse(v.begin(), v.end());",
            "        return v;",
            "    }",
            "    inline void clear() {",
            "        auto x = new Node(m_root->range().first, m_root->range().second);",
            "        m_root = x;",
            "        delete m_root;",
            "    }",
            "    ~ordered_multiset() {",
            "        delete m_root;",
            "    }",
            "    int lower_bound(int key) {",
            "        return find_by_order(order_of_key(key));",
            "    }",
            "    int upper_bound(int key) {",
            "        return lower_bound(key+1);",
            "    }",
            "};"
        ],
        "description": "orderedms"
    },
    "suffixarray": {
        "prefix": "suffixarray",
        "body": [
            "vector<int> suffix_array(string s) {",
            "    int n = s.size();",
            "    for(int i=0;i<2*n;i++) s += '$';",
            "    vector<int> sa(n),rank(2*n), temp(2*n);",
            "    iota(sa.begin(), sa.end(), 0);",
            "    for(int i=0;i<2*n;i++) rank[i] = s[i]-'a';",
            "    temp = rank;",
            "    for(int len=2;len<=2*n;len*=2) {",
            "        sort(sa.begin(), sa.end(), [&](int i, int j) {",
            "            if(rank[i] == rank[j]) return rank[len/2+i] < rank[len/2+j];",
            "            return rank[i] < rank[j];",
            "        });",
            "        temp[sa[0]] = 0;",
            "        for(int i=1;i<n;i++) {",
            "            temp[sa[i]] = temp[sa[i-1]];",
            "            if(rank[sa[i]]==rank[sa[i-1]]) {",
            "                if(rank[len/2+sa[i]]>rank[len/2+sa[i-1]]) {",
            "                    temp[sa[i]]++;",
            "                }",
            "            } else {",
            "                temp[sa[i]]++;",
            "            }",
            "        }",
            "        rank = temp;",
            "    }",
            "    return sa;",
            "}"
        ],
        "description": "suffixarray"
    },
    "kmp": {
        "prefix": "kmp",
        "body": [
            "vector<int> prefix(string s) {",
            "    int n = s.size();",
            "    vector<int> p(n);",
            "    for (int i = 1, j = 0; i < n; i++) {",
            "        while (j > 0 && s[i] != s[j]) j = p[j - 1];",
            "        if (s[i] == s[j]) j++;",
            "        p[i] = j;",
            "    }",
            "    return p;",
            "}"
        ],
        "description": "kmp"
    },
    "zfunc": {
        "prefix": "zfunc",
        "body": [
            "vector<int> Z(string s) {",
            "    int n = s.size();",
            "    vector<int> z(n);",
            "    for (int i = 1, l = 0, r = 0; i < n; i++) {",
            "        if (i <= r) z[i] = min(r - i + 1, z[i - l]);",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;",
            "        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}",
            ""
        ],
        "description": "zfunc"
    },
    "cht": {
        "prefix": "cht",
        "body": [
            "const double inf = 100000000000000.0;",
            "",
            "template<typename T>",
            "struct Line {",
            "    T m,c;",
            "    Line() {",
            "        m = c = 0;",
            "    }",
            "    Line(T m, T c) {",
            "        this->m = m;",
            "        this->c = c;",
            "    }",
            "    auto at(auto x) {",
            "        return m*x + c;",
            "    }",
            "};",
            "",
            "template<typename T, typename U> ",
            "double intersection(Line<T> l1, Line<U> l2) {",
            "    return double(l2.c - l1.c)/double(l1.m - l2.m);",
            "}",
            "",
            "struct Interval {",
            "    double start,end;",
            "    Interval(){",
            "        start = end = 0;",
            "    }",
            "    Interval(double s, double e) {",
            "        start = s, end = e;",
            "    }",
            "};",
            "",
            "template<typename T>",
            "struct Convex_Hull {",
            "    vector<Line<T>> lines;",
            "    vector<Interval> bounds;",
            "    Convex_Hull() {}",
            "",
            "    T at(T point) {",
            "        int index = lower_bound(bounds.begin(), bounds.end(), point, [](Interval i, T point) {",
            "            return i.end < point;",
            "        })-bounds.begin();",
            "        return lines[index].m*point + lines[index].c;",
            "    }",
            "",
            "    void addLine(Line<T> l) {",
            "        while(!lines.empty()) {",
            "            Line<T> line = lines.back();",
            "            if(line.at(bounds.back().start) >= l.at(bounds.back().start)) {",
            "                lines.pop_back();",
            "                bounds.pop_back();",
            "            }",
            "            else break;",
            "        }",
            "",
            "        if(lines.empty()) {",
            "            lines.push_back(l);",
            "            bounds.push_back(Interval(0,inf));",
            "        } ",
            "        else {",
            "            double new_start = intersection(l, lines.back());",
            "            bounds.back().end = new_start;",
            "            lines.push_back(l);",
            "            bounds.push_back(Interval(new_start,inf));",
            "        }",
            "    }",
            "};",
            "",
            "template<typename T>",
            "using CH = Convex_Hull<T>;"
        ],
        "description": "cht"
    },
    "gtbp": {
        "prefix": "gtbp",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define endl '\\n'",
            "#define ll long long",
            "#define all(x) x.begin(), x.end()",
            "#define rep(i,k,n) for(int i = k; i < n; i++)",
            "#define gt return 0",
            "",
            "void solve()",
            "{",
            "    $0",
            "}",
            "",
            "int main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    cout.tie(NULL);",
            "    int t;",
            "    cin >> t;",
            "    while(t--) {",
            "        solve();",
            "    }",
            "    gt;",
            "}"
        ],
        "description": "gtbp"
    },
    "interactive": {
        "prefix": "interactive",
        "body": [
            "struct Judge {",
            "    // Test data variables here",
            "    Judge()",
            "    {",
            "        #ifdef ONLINE_JUDGE",
            "        #else",
            "        // Init test data variables here",
            "        #endif",
            "    }",
            "    int query(int l, int r) {",
            "        #ifdef ONLINE_JUDGE",
            "            cout << \"? \" << l << \" \" << r << endl;",
            "            int result;",
            "            cin >> result;",
            "            return result;",
            "        #else",
            "        // implement logic for query here",
            "        #endif",
            "    }",
            "    int guess(auto x) {",
            "        #ifdef ONLINE_JUDGE",
            "            cout << \"! \" << x << endl;",
            "            return true;",
            "            // int x;",
            "            // cin >> x;",
            "            // return x;",
            "        #else",
            "        // Implement logic for checking here",
            "        #endif",
            "    }",
            "};"
        ],
        "description": "interactive"
    },
    "centroid": {
        "prefix": "centroid",
        "body": [
            "void getSize(int node, vi *adj, vector<bool> &taken, vector<int> &sub, int parent = 0) {",
            "    sub[node] = 1;",
            "    for(auto child:adj[node]) {",
            "        if(child == parent or taken[child]) continue;",
            "        getSize(child,adj,taken,sub,node);",
            "        sub[node] += sub[child];",
            "    }",
            "}",
            "",
            "int getCentroid(int node, vi *adj, vector<bool> &taken, vector<int> &sub, int totalSize, int parent = 0) {",
            "    int mx = 0, mxp = -1;",
            "    for(auto child:adj[node]) {",
            "        if(child == parent or taken[child]) continue;  ",
            "        if(sub[child] > mx) {",
            "            mx = sub[child], mxp = child;",
            "        } ",
            "    }",
            "    if(mx <= totalSize/2) return node;",
            "    return getCentroid(mxp,adj,taken,sub,totalSize,node);",
            "}",
            "",
            "vvi makeCD(int n, vi *adj, int &root) {",
            "    int cnt = 0;",
            "    vector<bool> taken(n+1);",
            "    vi sub;",
            "    vii roots;",
            "    vvi cd_adj(n+1);",
            "    roots.push_back({1,0});",
            "    while(cnt < n)",
            "    {",
            "        sub.assign(n+1,0);",
            "        vii x;",
            "        for(auto [node,parent]:roots) {",
            "            getSize(node,adj,taken,sub);",
            "            int centroid = getCentroid(node,adj,taken,sub,sub[node]);",
            "            taken[centroid] = 1;",
            "            cd_adj[parent].push_back(centroid);",
            "            if(parent)cd_adj[centroid].push_back(parent);",
            "            else root = centroid;",
            "            for(auto i:adj[centroid]) {",
            "                if(!taken[i]) x.push_back({i,centroid});",
            "            }",
            "            cnt++;",
            "        }",
            "        roots = x;",
            "    }",
            "    return cd_adj;",
            "}",
            ""
        ],
        "description": "centroid"
    },
    "ordered_multiset": {
        "prefix": "ordered_multiset",
        "body": [
            "",
            "template<typename T>",
            "class ordered_multiset {",
            "    ordered_set<pair<T,int>> os;",
            "public:",
            "    class iterator {",
            "        typename ordered_set<pair<T,int>>::iterator it;",
            "        public: ",
            "        using iterator_category = std::bidirectional_iterator_tag;",
            "        using difference_type   = std::ptrdiff_t;",
            "        using value_type        = T;",
            "        using pointer           = T*;",
            "        using reference         = T;",
            "        T operator*() const {",
            "            return it->first;",
            "        }",
            "        iterator(typename ordered_set<pair<T,int>>::iterator IT) {",
            "            it = IT;",
            "        }",
            "        iterator &operator++(){",
            "            this->it++;",
            "            return *this;",
            "        }",
            "        iterator &operator--(){",
            "            this->it--;",
            "            return *this;",
            "        }",
            "        iterator operator++(int32_t) {",
            "            iterator tmp = *this;",
            "            ++(*this);",
            "            return tmp;",
            "        }",
            "        iterator operator--(int32_t) {",
            "            iterator tmp = *this;",
            "            --(*this);",
            "            return tmp;",
            "        }",
            "        friend bool operator!=(const iterator &a, const iterator &b) {",
            "            return a.it != b.it;",
            "        }",
            "        friend bool operator==(const iterator &a, const iterator &b) {",
            "            return a.it == b.it;",
            "        }",
            "    };",
            "    iterator begin() {",
            "        return iterator(os.begin());",
            "    }",
            "    iterator end() {",
            "        return iterator(os.end());",
            "    }",
            "    iterator lower_bound(T val) {",
            "        return iterator(os.lower_bound(make_pair(val,0)));",
            "    }",
            "    iterator upper_bound(T val) {",
            "        return iterator(os.upper_bound(make_pair(val,INT_MAX)));",
            "    }",
            "    int order_of_key(T val) {",
            "        return os.order_of_key(make_pair(val,0));",
            "    }",
            "    iterator find_by_order(int x) {",
            "        return iterator(os.find_by_order(x));",
            "    }",
            "    int size() {",
            "        return os.size();",
            "    }",
            "    bool empty() {",
            "        return os.empty();",
            "    }",
            "    int count(T val) {",
            "        return os.order_of_key(make_pair(val,INT_MAX))-os.order_of_key(make_pair(val,0));",
            "    }",
            "    void insert(T val) {",
            "        int count_val = count(val);",
            "        if(count_val) os.insert(make_pair(val,count_val));",
            "        else os.insert(make_pair(val,0));",
            "    }",
            "    void erase(T val) {",
            "        if(count(val) == 0) return;",
            "        os.erase(make_pair(val,count(val)-1));",
            "    }",
            "    void eraseAll(T val) {",
            "        int count_val = count(val);",
            "        while (count_val) {",
            "            count_val--;",
            "            os.erase(make_pair(val,count_val));",
            "        }",
            "    }",
            "};"
        ],
        "description": "ordered_multiset"
    },
    "scalingFlow": {
        "prefix": "scalingFlow",
        "body": [
            "int runningIdx = 0;",
            "",
            "struct Edge {",
            "    int u,v;",
            "    int flow, capacity, index;",
            "    Edge(int from, int to, int capacity, int flow) {",
            "        v = to, u = from, this->capacity = capacity, this->flow = flow, index = runningIdx;",
            "    }",
            "};",
            "",
            "ostream &operator<<(ostream &ost, Edge e) {",
            "    ost << e.u << \"->\" << e.v << \" flow: \" << e.flow << \"/\" << e.capacity;",
            "    return ost;",
            "}",
            "",
            "vector<vector<Edge>> adj;",
            "",
            "void addEdge(int u, int v, int cap) {",
            "    adj[u].push_back(Edge(u,v,cap,0));",
            "    adj[v].push_back(Edge(v,u,0,0));",
            "    runningIdx++;",
            "}",
            "",
            "int augment(int source, int sink, int c, int pathMin, vector<bool> &vis, int lastNode = 0, int lastIndex = 0) {",
            "    if(source == sink) {",
            "        for(auto &edge:adj[source]) {",
            "            if(edge.index == lastIndex) edge.flow -= pathMin;",
            "        }",
            "        return pathMin;",
            "    }",
            "    vis[source] = 1;",
            "    for(auto &edge:adj[source]) {",
            "        if(vis[edge.v]) continue;",
            "        int resFlow = edge.capacity-edge.flow;",
            "        if(resFlow >= c) {",
            "            int x = augment(edge.v,sink,c,min(pathMin,resFlow),vis,source,edge.index);",
            "            if(x) {",
            "                if(lastNode) {",
            "                    for(auto &edge:adj[source]) {",
            "                        if(edge.index == lastIndex) edge.flow -= x;",
            "                    }",
            "                }",
            "                edge.flow += x;",
            "                return x;",
            "            }",
            "        }",
            "    }",
            "    return 0;",
            "}",
            "",
            "int maxFlow(int source, int sink) {",
            "    int c = 0;",
            "    for(int i=1;i<adj.size();i++) {",
            "        for(auto edge:adj[i]) {",
            "            c = max(c,edge.capacity);",
            "        }",
            "    }",
            "    int flow = 0;",
            "    while(c) {",
            "        vector<bool> vis(adj.size()+1,false);",
            "        int x = augment(source,sink,c,2*c,vis);",
            "        if(not x) c /= 2;",
            "        else flow += x; ",
            "    }",
            "    return flow;",
            "}",
            ""
        ],
        "description": "scalingFlow"
    },
    "dinitz": {
        "prefix": "dinitz",
        "body": [
            "struct Edge {",
            "    int u,v;",
            "    int flow, capacity;",
            "    Edge(int from, int to, int capacity, int flow) {",
            "        v = to, u = from, this->capacity = capacity, this->flow = flow;",
            "    }",
            "};",
            "",
            "ostream &operator<<(ostream &ost, Edge e) {",
            "    ost << e.u << \"->\" << e.v << \" flow: \" << e.flow << \"/\" << e.capacity;",
            "    return ost;",
            "}",
            "",
            "struct Dinitz {",
            "    int n, m = 0, source, sink;",
            "    vector<Edge> edge;",
            "    vector<vector<int>> adj;",
            "    vector<int> level;",
            "    vector<int> ptr;",
            "    int INF = 2147483648ll*2147483648ll+INT_MAX;",
            "",
            "    Dinitz(int n, int source, int sink) {",
            "        this->n = n, this->source = source, this->sink = sink;",
            "        adj.resize(n+1);",
            "        level.resize(n+1);",
            "        ptr.resize(n+1);",
            "    }",
            "",
            "    void addEdge(int u, int v, int cap) {",
            "        edge.push_back(Edge(u,v,cap,0));",
            "        adj[u].push_back(m++);",
            "        edge.push_back(Edge(v,u,0,0));",
            "        adj[v].push_back(m++);",
            "    }",
            "",
            "    // returns if augmenting path exists",
            "    bool bfs() {",
            "        queue<int> q;",
            "        q.push(source);",
            "        fill(all(level),-1);",
            "        level[source] = 0;",
            "        while (!q.empty())",
            "        {",
            "            int node = q.front();",
            "            q.pop();",
            "            for(auto i:adj[node]) {",
            "                int child = edge[i].v;",
            "                if(level[child] != -1) continue;",
            "                if(edge[i].capacity == edge[i].flow) continue;",
            "                level[child] = level[node]+1;",
            "                q.push(child);",
            "            }",
            "        }",
            "        return level[sink] != -1;",
            "    }",
            "",
            "    //augment and blocks paths",
            "    int dfs(int node, int pathMin) {",
            "        if(pathMin == 0) return 0;",
            "        if(node == sink) return pathMin;",
            "        for(int &i = ptr[node]; i < adj[node].size(); ++i) {",
            "            int child = edge[adj[node][i]].v, resFlow = edge[adj[node][i]].capacity - edge[adj[node][i]].flow;",
            "            if(level[child] != level[node]+1 or resFlow == 0) continue;",
            "            int pushed = dfs(child,min(resFlow,pathMin));",
            "            if(not pushed) continue;",
            "            edge[adj[node][i]].flow += pushed;",
            "            edge[adj[node][i]^1].flow -= pushed;",
            "            return pushed;",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    int maxFlow() {",
            "        int flow = 0;",
            "        while (bfs()) {",
            "            fill(all(ptr),0);",
            "            while(int pushed = dfs(source,INF)) {",
            "                flow += pushed;",
            "            }",
            "        }",
            "        return flow;       ",
            "    }",
            "};"
        ],
        "description": "dinitz"
    },
    "tree": {
        "prefix": "tree",
        "body": [
            "template<bool DP = true>",
            "struct Tree {",
            "    int n;",
            "    vector<int> depth,parent,sub,dp,val;",
            "    vector<vector<int>> adj;",
            "    Tree(int n, int root = 1): n(n) {",
            "        depth.resize(n+1);parent.resize(n+1);",
            "        sub.resize(n+1);adj.resize(n+1);",
            "        if(DP) {",
            "            val.resize(n+1);",
            "            dp.resize(n+1);",
            "            for(int i=1;i<=n;i++) cin >> val[i];",
            "        }",
            "        inputEdges();",
            "        initDFS();",
            "    }",
            "    void inputEdges() {",
            "        for(int i=0;i<n-1;i++) {",
            "            int u,v;",
            "            cin >> u >> v;",
            "            adj[u].push_back(v);",
            "            adj[v].push_back(v);",
            "        }",
            "    }",
            "    void initDFS(int node = 1, int par = 0, int dep = 0) {",
            "        parent[node] = par, depth[node] = dep, sub[node] = 1;",
            "        for(auto child:adj[node]) {",
            "            if(child == par) continue;",
            "            initDFS(child,node,dep+1);",
            "            sub[node] += sub[child];",
            "        }",
            "    }",
            "",
            "    void DFS(int node) {",
            "        // init dp",
            "        for(auto child:adj[node]) {",
            "            if(child == parent[node]) continue;",
            "            DFS(child);",
            "            //combine dp",
            "        }",
            "    }",
            "    ",
            "    int &getSize(int x) {return sub[x];}",
            "    int &getDP(int x) {return dp[x];}",
            "    int &getDepth(int x) {return depth[x];}",
            "    vector<int> &getNeighbours(int x) {return adj[x];}",
            "    int &getParent(int x) {return parent[x];}",
            "};"
        ],
        "description": "tree"
    },
    "fft": {
        "prefix": "fft",
        "body": [
            "mint2 proot = 3, iproot = mint2(1)/3;",
            "",
            "struct Polynomial {",
            "    vector<mint2> a;",
            "    Polynomial(int n) {",
            "        if((n&(n-1))) {",
            "            while ((n&(n-1))) {",
            "                n = (n&(n-1));",
            "            }",
            "            n *= 2;",
            "        }",
            "        a.resize(n);",
            "    }",
            "    Polynomial(vector<int> v, int n) {",
            "        proot = 3, iproot = mint2(1)/3;",
            "        if((n&(n-1))) {",
            "            while ((n&(n-1))) {",
            "                n = (n&(n-1));",
            "            }",
            "            n *= 2;",
            "        }",
            "        a.resize(n);",
            "        for(int i=0;i<v.size();i++) a[i] = v[i];",
            "    }",
            "    Polynomial(vector<int> v) {",
            "        *this = Polynomial(v,v.size());",
            "    }",
            "    int size() {",
            "        return a.size();",
            "    }",
            "    mint2 &operator[](int x) {",
            "        return a[x];",
            "    }",
            "    void resize(int n) {",
            "        if((n&(n-1))) {",
            "            while ((n&(n-1))) {",
            "                n = (n&(n-1));",
            "            }",
            "            n *= 2;",
            "        }",
            "        a.resize(n,0);",
            "    }",
            "};",
            "",
            "void fft(Polynomial &p, bool invert = false) {",
            "    int n = p.size();",
            "    mint2 root = ((invert ? iproot : proot)^((mod2-1)/n));",
            "    for (int i = 1, j = 0; i < n; i++) {",
            "        int bit = (n >> 1);",
            "        while((j & bit)) {",
            "            j ^= bit;",
            "            bit >>= 1;",
            "        }",
            "        j ^= bit;",
            "        if (i < j) {",
            "            swap(p[i], p[j]);",
            "        }",
            "    }",
            "",
            "    for(int len = 2; len <= n; len <<= 1) {",
            "        mint2 eff_root = root;",
            "        for(int i=len;i<n;i<<=1) {",
            "            eff_root *= eff_root;",
            "        }",
            "        for(int i=0;i<n;i+=len) {",
            "            mint2 w = 1;",
            "            for(int j=0;j<len/2;j++) {",
            "                auto u = p[i+j], v = w*p[i+j+len/2];",
            "                p[i+j] = u+v, p[i+j+len/2] = u-v;",
            "                w *= eff_root;",
            "            }",
            "        }",
            "    }",
            "    if(invert) {",
            "        mint2 NInverse = mint2(1)/n;",
            "        for(int i=0;i<n;i++) p[i] *= NInverse;",
            "    }",
            "}",
            "",
            "",
            "Polynomial operator*(Polynomial p1, Polynomial p2) {",
            "    int n = p1.size()+p2.size();",
            "    p1.resize(n);p2.resize(n);",
            "    fft(p1);fft(p2);",
            "    for(int i=0;i<p1.size();i++) p1[i] *= p2[i];",
            "    fft(p1,true);",
            "    return p1;",
            "}"
        ],
        "description": "fft"
    },
    "hld": {
        "prefix": "hld",
        "body": [
            "struct HLD {",
            "    struct segTree {",
            "        int n;",
            "        vector<int> tree,change;",
            "        segTree(vector<int> v) {",
            "            n = v.size();",
            "            tree.resize(4*n);",
            "            change.assign(4*n,-1);",
            "            build(v,0,n-1,0);",
            "        }",
            "",
            "        segTree() {}",
            "",
            "        void merge(int ind) {",
            "            tree[ind]  = tree[2*ind+1] + tree[2*ind+2];",
            "        }",
            "",
            "        void build(vector<int> &v, int st, int en, int ind) {",
            "            if(st == en) tree[ind] = v[st];",
            "            else {",
            "                int mid = (st+en)/2;",
            "                build(v, st, mid,2*ind+1);",
            "                build(v,mid+1,en,2*ind+2);",
            "                merge(ind);",
            "            }",
            "        }",
            "        ",
            "        void pushdown(int ind, int st, int en) {",
            "            if(change[ind] == -1) return;",
            "            int leftChild = 2*ind+1, rightChild = 2*ind+2, mid = (st+en)/2;",
            "            change[leftChild] = change[ind];",
            "            change[rightChild] = change[ind];",
            "            change[ind] = -1;",
            "            tree[leftChild] = (mid-st+1)*change[leftChild];",
            "            tree[rightChild] = (en-mid)*change[rightChild];",
            "        }",
            "",
            "        void update(int pos, int val, int st, int en, int ind) {",
            "            if(pos > en or pos < st) return;",
            "            if(st == en) tree[ind] = val;",
            "            else {",
            "                int mid = (st+en)/2;",
            "                pushdown(ind,st,en);",
            "                update(pos, val, st, mid, 2*ind+1);",
            "                update(pos,val,mid + 1,en,2*ind+2);",
            "                merge(ind);",
            "            }",
            "        }",
            "",
            "        void update(int l, int r, int val, int st, int en, int ind) {",
            "            if(l > en or r < st) return;",
            "            if(l <= st and en <= r) {",
            "                tree[ind] = (en-st+1)*val;",
            "                change[ind] = val;",
            "            } else {",
            "                int mid = (st+en)/2;",
            "                pushdown(ind,st,en);",
            "                update(l,r, val, st, mid, 2*ind+1);",
            "                update(l,r,val,mid + 1,en,2*ind+2);",
            "                merge(ind);  ",
            "            }",
            "        }",
            "",
            "        void update(int pos, int val) {",
            "            update(pos,val,0,n-1,0);",
            "        }",
            "",
            "        void update(int l, int r, int val) {",
            "            update(l,r,val,0,n-1,0);",
            "        }",
            "",
            "        int query(int l, int r, int st, int en, int ind) {",
            "            if(l > en or r < st) return 0;",
            "            if(l <= st and en <= r) return tree[ind];",
            "            else {",
            "                if(st == en) return tree[ind];",
            "                int mid = (st+en)/2;",
            "                pushdown(ind,st,en);",
            "                auto a = query(l,r, st, mid,2*ind+1);",
            "                auto b = query(l,r,mid+1,en,2*ind+2);",
            "                auto c = a+b;",
            "                return c;",
            "            }",
            "        }",
            "",
            "        int query(int l, int r) {",
            "            return query(l,r,0,n-1,0);",
            "        }",
            "    };",
            "    int n, mxN, temp = 0;",
            "    vector<int> subSize, depth, top, heavy, val, euler, label;",
            "    vector<vector<int>> parent,adj;",
            "    segTree st;",
            "    HLD(int n):n(n){",
            "        mxN = 32 - __builtin_clz(n);",
            "        subSize = depth = top = heavy = val = label = vector<int>(n+1);",
            "        euler = vector<int>(n);",
            "        depth[0] = -1;",
            "        parent.assign(n+1,vector<int>(mxN));",
            "        adj.resize(n+1);",
            "        input();",
            "        init();",
            "        dfs();",
            "        st = segTree(euler);",
            "    }",
            "",
            "    void input() {",
            "        for(int i=1;i<=n;i++) cin >> val[i];",
            "        for(int i=0;i<n-1;i++) {",
            "            int u,v;",
            "            cin >> u >> v;",
            "            adj[u].push_back(v);",
            "            adj[v].push_back(u);",
            "        }",
            "    }",
            "",
            "    void init(int node = 1, int par = 0, int dep = 0) {",
            "        depth[node] = dep;",
            "        subSize[node] = 1;",
            "        parent[node][0] = par;",
            "        for(int i=1;i<mxN;i++) {",
            "            parent[node][i] = parent[parent[node][i-1]][i-1];",
            "        }",
            "        for(auto child:adj[node]) {",
            "            if(child == par) continue;",
            "            init(child,node,dep+1);",
            "            subSize[node] += subSize[child];",
            "        }",
            "    }",
            "",
            "    void dfs(int node = 1, int toc = 1) {",
            "        int heavyChild = -1;",
            "        top[node] = toc;",
            "        label[node] = temp++;",
            "        euler[label[node]] = val[node];",
            "        for(auto child:adj[node]) {",
            "            if(child != parent[node][0]) {",
            "                if(heavyChild == -1 or subSize[heavyChild] < subSize[child]) ",
            "                    heavyChild = child;",
            "            }",
            "        }",
            "        heavy[node] = heavyChild;",
            "        if(heavyChild != -1) {",
            "            dfs(heavyChild,toc);",
            "            for(auto child:adj[node]) {",
            "                if(child != heavyChild and child != parent[node][0]) {",
            "                    dfs(child,child);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    int lca(int u, int v) {",
            "        if(depth[u] < depth[v]) swap(u,v);",
            "        for(int i = mxN-1; i >= 0; i--) if(depth[u]-(1<<i) >= depth[v]) u = parent[u][i];",
            "        if(u == v) return v;",
            "        for(int i = mxN-1; i >= 0; i--) {",
            "            if(parent[u][i] != parent[v][i]){",
            "                u = parent[u][i];",
            "                v = parent[v][i];",
            "            }",
            "        }",
            "        return parent[u][0];",
            "    }",
            "",
            "    int get_kth(int node, int k) {",
            "        for(int i = mxN-1; i >= 0; i--) if((k&(1<<i))) node = parent[node][i];",
            "        return node;",
            "    }",
            "",
            "    // returns answers from par to child both inclusive",
            "    int queryChain(int par, int child) {",
            "        int result = 0;",
            "        while (true)",
            "        {",
            "            if(depth[child] < depth[par]) break;",
            "            if(child == par) {",
            "                result += query(child);",
            "                break;",
            "            }",
            "            else if(depth[top[child]] >= depth[par]) {",
            "                result += st.query(label[top[child]],label[child]);",
            "                child = top[child];",
            "                child = parent[child][0];",
            "            } else {",
            "                result += st.query(label[par],label[child]);",
            "                break;",
            "            }",
            "        }",
            "        return result;",
            "    }",
            "",
            "    // returns answer of single node",
            "    int query(int node) {",
            "        return st.query(label[node],label[node]);",
            "    }",
            "",
            "    int query(int u, int v) {",
            "        int l = lca(u,v);",
            "        int res = 0;",
            "        res += queryChain(l,u);",
            "        if(depth[v]-depth[l]-1 >= 0) {",
            "            l = get_kth(v,depth[v]-depth[l]-1);",
            "            res += queryChain(l,v);",
            "        }",
            "        return res;",
            "    }",
            "",
            "    void updateChain(int par, int child, int val) {",
            "        while (true)",
            "        {",
            "            if(depth[child] < depth[par]) break;",
            "            if(child == par) {",
            "                update(child,val);",
            "                break;",
            "            }",
            "            else if(depth[top[child]] >= depth[par]) {",
            "                st.update(label[top[child]],label[child],val);",
            "                child = top[child];",
            "                child = parent[child][0];",
            "            } else {",
            "                st.update(label[par],label[child],val);",
            "                break;",
            "            }",
            "        }",
            "    }",
            "",
            "    void update(int node, int val) {",
            "        st.update(label[node],val);",
            "    }",
            "",
            "    void update(int u, int v, int val) {",
            "        int l = lca(u,v);",
            "        updateChain(u,v,val);",
            "        if(depth[v]-depth[l]-1 >= 0) {",
            "            l = get_kth(v,depth[v]-depth[l]-1);",
            "            updateChain(l,v,val);",
            "        }",
            "    }",
            "};"
        ],
        "description": "hld"
    },
    "2sat": {
        "prefix": "2sat",
        "body": [
            "struct TwoSAT {",
            "    int nodes;",
            "    vvi adj, adj_rev, components;",
            "    vector<bool> used;",
            "    vector<int> order;",
            "",
            "    TwoSAT(int nodes) {",
            "        this->nodes = nodes;",
            "        adj.resize(2*nodes);",
            "        adj_rev.resize(2*nodes);",
            "    }",
            "",
            "    int NOT(int x) {",
            "        return x >= nodes ? x - nodes : x + nodes;",
            "    }",
            "",
            "    void addDep(int x, int y) {",
            "        adj[NOT(x)].pb(y);",
            "        adj[NOT(y)].pb(x);",
            "        adj_rev[x].pb(NOT(y));",
            "        adj_rev[y].pb(NOT(x));",
            "    }",
            "",
            "    void dfs1(int v) {",
            "        used[v] = true;",
            "        for (auto u : adj[v]) {",
            "            if (!used[u]) {",
            "                dfs1(u);",
            "            }",
            "        }",
            "        order.push_back(v);",
            "    }",
            "",
            "    void dfs2(int v) {",
            "        used[v] = true;",
            "        components.back().push_back(v);",
            "        for (auto u : adj_rev[v]) {",
            "            if (!used[u]) {",
            "                dfs2(u);",
            "            }",
            "        }",
            "    }",
            "",
            "    void SCC() {",
            "        used.assign(2*nodes, false);",
            "",
            "        for (int i = 0; i < 2*nodes; i++) {",
            "            if (!used[i]) {",
            "                dfs1(i);",
            "            }",
            "        }",
            "",
            "        used.assign(2*nodes, false);",
            "        reverse(order.begin(), order.end());",
            "",
            "        for (auto v : order) {",
            "            if (!used[v]) {",
            "                components.push_back({});",
            "                dfs2 (v);",
            "            }",
            "        }",
            "        trace(components);",
            "    }",
            "",
            "    bool verify() {",
            "        SCC();",
            "        for(auto i:components) {",
            "            sort(all(i));",
            "            for(auto j:i) {",
            "                if(j >= nodes) break;",
            "                if(binary_search(all(i),NOT(j))) return false;",
            "            }",
            "        }",
            "        return true;",
            "    }",
            "};",
            ""
        ],
        "description": "2sat"
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "vector<int> manacher_odd(string s) {",
            "    int n = s.size();",
            "    s = \"$\" + s + \"^\";",
            "    vector<int> p(n + 2);",
            "    int l = 1, r = 1;",
            "    for(int i = 1; i <= n; i++) {",
            "        p[i] = max(0, min(r - i, p[l + (r - i)]));",
            "        while(s[i - p[i]] == s[i + p[i]]) {",
            "            p[i]++;",
            "        }",
            "        if(i + p[i] > r) {",
            "            l = i - p[i], r = i + p[i];",
            "        }",
            "    }",
            "    return vector<int>(begin(p) + 1, end(p) - 1);",
            "}",
            "",
            "pair<vi,vi> manacher(string s) {",
            "    string t;",
            "    for(auto c: s) {",
            "        t += string(\"#\") + c;",
            "    }",
            "    auto res = manacher_odd(t + \"#\");",
            "    vi odd, even;",
            "    rep(i,1,res.size()-1) {",
            "        if(i%2) odd.push_back(res[i]/2);",
            "        else even.push_back((res[i]-1)/2);",
            "    }",
            "    return {odd,even};",
            "}"
        ],
        "description": "manacher"
    },
    "hashing2": {
        "prefix": "hashing2",
        "body": [
            "long long Power(long long a,long long b,long long modulo)",
            "{",
            "    long long prod = a;",
            "    long long ans = 1;",
            "    while(b){",
            "        if(b%2) ans = (ans*prod)%modulo;",
            "        b /= 2;",
            "        prod = (prod*prod)%modulo;",
            "    }",
            "    return ans;",
            "}",
            " ",
            "bool initFlag = false;",
            "constexpr int largeprimes[] = {1000000007,1000000009,1000000021,1000000033,1000000087,1000000093,1000000097,1000000103,1000000123,1000000181,1000000207,1000000223,1000000241};",
            "template<int pCount = 2>",
            "struct Hash {",
            "    inline static long long mod[pCount], baseInv[pCount];",
            "    inline static const int base = 31;",
            "    static void init() {",
            "        if(initFlag) return;",
            "        initFlag = true;",
            "        rep(i,0,pCount) mod[i] = largeprimes[abs(int(rng()))%13];",
            "        rep(i,0,pCount) baseInv[i] = Power(base,mod[i]-2,mod[i]);",
            "        cerr << \"Hash initialised, mods = \" << mod[0] << \" \" << mod[1] << \"\\n\";",
            "    }",
            " ",
            " ",
            "    long long hash[pCount], toMul[pCount], toDiv[pCount];",
            "    int length;",
            " ",
            "    Hash() {",
            "        init();",
            "        memset(hash,0,sizeof hash); fill(toMul,toMul+pCount,1),fill(toDiv,toDiv+pCount,1); length = 0;",
            "    }",
            " ",
            "    Hash(string s) {",
            "        init();",
            "        memset(hash,0,sizeof hash); fill(toMul,toMul+pCount,1),fill(toDiv,toDiv+pCount,1); length = 0;",
            "        for(char c:s) this->push_back(c);",
            "    }",
            " ",
            " ",
            "    inline void add(long long &a, long long b, int i) {",
            "        a += b; a -= (a > mod[i])*mod[i];",
            "    }",
            " ",
            "    inline void sub(long long &a, long long b, int i) {",
            "        a -= b; a += (a < 0)*mod[i];",
            "    }",
            " ",
            "    inline void mul(long long &a, long long b, int i) {",
            "        a *= b; a %= mod[i];",
            "    }",
            " ",
            "    inline void div(long long &a, long long b, int i) {",
            "        a *= Power(b,mod[i]-2,mod[i]); a %= mod[i];",
            "    }",
            " ",
            "    void push_back(char c) {",
            "        length++;",
            "        rep(i,0,pCount) {",
            "            long long pVal = c-'a'+1;",
            "            mul(pVal,toMul[i],i);",
            "            add(hash[i],pVal,i);",
            "            mul(toMul[i],base,i);",
            "            mul(toDiv[i],baseInv[i],i);",
            "        }",
            "    }",
            " ",
            "    void push_front(char c) {",
            "        length++;",
            "        rep(i,0,pCount) {",
            "            long long pVal = c-'a'+1;",
            "            mul(hash[i],base,i); ",
            "            add(hash[i],pVal,i);",
            "            mul(toMul[i],base,i);",
            "            mul(toDiv[i],baseInv[i],i);",
            "        }",
            "    }",
            " ",
            "    void pop_back(char c) {",
            "        length--;",
            "        rep(i,0,pCount) {",
            "            long long pVal = c-'a'+1;",
            "            mul(toMul[i],baseInv[i],i);",
            "            mul(toDiv[i],base,i);",
            "            mul(pVal,toMul[i],i);",
            "            sub(hash[i],pVal,i);",
            "        }",
            "    }",
            " ",
            "    void pop_front(char c) {",
            "        length--;",
            "        rep(i,0,pCount) {",
            "            long long pVal = c-'a'+1;",
            "            sub(hash[i],pVal,i); ",
            "            mul(hash[i],baseInv[i],i);",
            "            mul(toMul[i],baseInv[i],i);",
            "            mul(toDiv[i],base,i);",
            "        }",
            "    }",
            "",
            "    void pop_front(Hash h) {",
            "        length -= h.length;",
            "        rep(i,0,pCount) {",
            "            sub(hash[i],h.hash[i],i);",
            "            mul(hash[i],h.toDiv[i],i);",
            "            mul(toMul[i],h.toDiv[i],i);",
            "            mul(toDiv[i],h.toMul[i],i);",
            "        }",
            "    }",
            " ",
            "    bool operator==(Hash h) {",
            "        if(this->length != h.length) return false;",
            "        rep(i,0,pCount) {",
            "            if(this->hash[i] != h.hash[i]) return false;",
            "        }",
            "        return true;",
            "    }",
            " ",
            "    bool operator<(Hash h) {",
            "        if(this->length < h.length) return true;",
            "        else if(this->length > h.length) return false;",
            "        rep(i,0,pCount) {",
            "            if(this->hash[i] < h.hash[i]) return true;",
            "            if(this->hash[i] > h.hash[i]) return false;",
            "        }",
            "        return false;",
            "    }",
            " ",
            "    Hash operator=(Hash h) {",
            "        this->length = h.length;",
            "        rep(i,0,pCount) this->hash[i] = h.hash[i], this->toMul[i] = h.toMul[i], this->toDiv[i] = h.toDiv[i];",
            "        return h;",
            "    }",
            " ",
            "    Hash operator+(Hash h) {",
            "        Hash x = *this;",
            "        x.length += h.length;",
            "        rep(i,0,pCount) {",
            "            mul(h.hash[i],x.toMul[i],i);",
            "            add(x.hash[i],h.hash[i],i);",
            "            mul(x.toMul[i],h.toMul[i],i);",
            "            mul(x.toDiv[i],h.toDiv[i],i);",
            "        }",
            "        return x;",
            "    }",
            "};",
            " ",
            "template<int pCount = 2>",
            "ostream &operator<<(ostream &ost, Hash<pCount> h) {",
            "    ost << \"[\" << h.length;",
            "    rep(i,0,pCount) cout << \", \" << h.hash[i];",
            "    cout << \"]\";",
            "    return ost;",
            "}"
        ],
        "description": "hashing2"
    },
    "factorise": {
        "prefix": "factorise",
        "body": [
            "mii pf;",
            "while(${0:x} > 1) {",
            "    pf[spf[${0:x}]]++;",
            "    ${0:x} /= spf[${0:x}];",
            "}",
            "vi factors(1,1);",
            "for(auto i:pf) {",
            "    int k = factors.size();",
            "    int y = i.first;",
            "    rep(j,0,i.second) {",
            "        rep(l,0,k) {",
            "            factors.push_back(factors[l]*y);",
            "        }",
            "        y *= i.first;",
            "    }",
            "}"
        ],
        "description": "factorise"
    },
    "gen": {
        "prefix": "gen",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "//#pragma GCC target (\"avx2\")",
            "//#pragma GCC optimize (\"O3\")",
            "//#pragma GCC optimize (\"unroll-loops\")",
            "",
            "// #include<bits/extc++.h>",
            "// using namespace __gnu_pbds;",
            "// template<typename T>",
            "// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "// template<typename T>",
            "// using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "// #define ook order_of_key",
            "// #define fbo find_by_order",
            "",
            "#define _green \"\\033[1;32m\"",
            "#define _yellow \"\\033[1;33m\"",
            "#define _orange \"\\033[1;34m\"",
            "#define _purple \"\\033[1;35m\"",
            "#define _blue \"\\033[1;36m\"",
            "#define trace(...) __f(__LINE__,_yellow,#__VA_ARGS__, __VA_ARGS__)",
            "#define Trace(color,...) __f(__LINE__,color,#__VA_ARGS__, __VA_ARGS__)",
            "#define wait(x) this_thread::sleep_for(chrono::milliseconds(x))",
            "#define seed chrono::steady_clock::now().time_since_epoch().count()",
            "#define makegraph(adj, num)       \\",
            "    for (int i = 0; i < num; i++) \\",
            "    {                             \\",
            "        int u, v;                 \\",
            "        cin >> u >> v;            \\",
            "        adj[u].push_back(v);      \\",
            "        adj[v].push_back(u);      \\",
            "    }",
            "#define rep(i, k, n) for (int i = k; i < n; i++)",
            "#define rept(i, k, n) for (auto i = k; i != n; ++i)",
            "#define drep(i, k, n) for (int i = k; i >= n; i--)",
            "#define pb push_back",
            "#define mp make_pair",
            "#define ub upper_bound",
            "#define lb lower_bound",
            "#define all(a) a.begin(), a.end()",
            "#define endl '\\n'",
            "#define ll long long",
            "#define newint(...) int __VA_ARGS__;read(__VA_ARGS__);",
            "#define setbits(x) __builtin_popcount(x)",
            "#define setbitsll(x) __builtin_popcountll(x)",
            "#define Tj return",
            "#define out 0",
            "// #define segtree",
            "#ifdef segtree",
            "#define mid (st + en) / 2",
            "#define lidx 2 * ind + 1",
            "#define ridx 2 * ind + 2",
            "#define left st, mid, lidx, seg",
            "#define right mid + 1, en, ridx, seg",
            "#endif",
            "typedef vector<int> vi;",
            "typedef vector<pair<int, int>> vii;",
            "typedef pair<int, int> ii;",
            "typedef pair<int, pair<int, int>> iii;",
            "typedef map<int, int> mii;",
            "typedef map<char, int> mci;",
            "typedef set<int> si;",
            "typedef vector<vector<int>> vvi;",
            "typedef __int128_t xll;",
            "const int intmax = 2147483647;",
            "const int intmin = -2147483648;",
            "const int mod = 1000000007;",
            "const int mod2 = 998244353;",
            "mt19937 rng(seed);",
            "",
            "//IO operators for vectors, pairs, sets, maps and __int128",
            "template <typename T>istream &operator>>(istream &in, vector<T> &v);",
            "template <typename T>ostream &operator<<(ostream &ost, vector<T> v);",
            "template <typename T>ostream &operator<<(ostream &ost, set<T> s);",
            "template <typename T>ostream &operator<<(ostream &ost, multiset<T> s);",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, map<U,V> &m);",
            "template <typename U, typename V>istream &operator>>(istream &in, pair<U, V> &p);",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, pair<U, V> p);",
            "ostream &operator<<(ostream &ost, __int128_t x);",
            "istream &operator>>(istream &in, __int128_t &x);",
            "// Variadic IO",
            "template <typename... T>void read(T &...args);",
            "template <typename... T>void print(T... args);",
            "// Debug",
            "template <typename Arg1> void __f(int line, const char *color, const char* name, Arg1&& arg1);",
            "template <typename Arg1, typename... Args> void __f(int line, const char *color, const char* names, Arg1&& arg1, Args&&... args);",
            "",
            "",
            "#define rnd(x, y) uniform_int_distribution<long long int>(x, y)(rng)",
            "",
            "inline int randomIndex(int maxInd) {",
            "    return abs(int(rng()))%maxInd; ",
            "}",
            "",
            "template<typename T>",
            "inline void randomShuffle(vector<T> &v){",
            "    for(int i=0;i<v.size();i++){",
            "        int j = randomIndex(i+1);",
            "        swap(v[j],v[i]);",
            "    }",
            "}",
            "",
            "template<typename T>",
            "inline void randomShuffle(T *arr, int sz){",
            "    for(int i=0;i<sz;i++){",
            "        int j = randomIndex(i+1);",
            "        swap(arr[j],arr[i]);",
            "    }",
            "}",
            "",
            "vector<int> randomPermutation(int n) {",
            "    vector<int> v(n); iota(all(v),1);",
            "    randomShuffle(v);",
            "    return v;",
            "}",
            "",
            "vector<int> randomArray(int n, int from = 1, int to = 1000000000) {",
            "    vi v(n);",
            "    generate(all(v),[from,to]() {",
            "        return rnd(from,to);",
            "    });",
            "    return v;",
            "}",
            "",
            "vector<int> randomDistinctArray(int n, int from = 1, int to = 1000000000) {",
            "    si s;",
            "    while(s.size() < n) s.insert(rnd(from,to));",
            "    vi v(all(s)); randomShuffle(v);",
            "    return v;",
            "}",
            "",
            "void solve()",
            "{",
            "    $0",
            "}",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "    freopen(\"input.txt\",\"w\",stdout);",
            "    int t=1;",
            "    cin >> t;",
            "    cout << t;",
            "    rep(var,1,t+1)",
            "        // cout << \"Case #\" << var << \": \",",
            "        solve();",
            "    Tj out;",
            "}",
            "",
            "//IO operators for vectors, pairs, sets, maps and __int128",
            "template <typename T>istream &operator>>(istream &in, vector<T> &v){for (auto &i : v)in >> i;return in;}",
            "template <typename T>ostream &operator<<(ostream &ost, vector<T> v){if(&ost == &cerr){cerr <<\"{\";int cnt = v.size();for(auto x:v){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:v)ost << i << \" \";return ost;}",
            "template <typename T>ostream &operator<<(ostream &ost, set<T> s){if(&ost == &cerr){cerr <<\"{\";int cnt = s.size();for(auto x:s){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:s)ost << i << \" \";return ost;}",
            "template <typename T>ostream &operator<<(ostream &ost, multiset<T> s){if(&ost == &cerr){cerr <<\"{\";int cnt = s.size();for(auto x:s){cerr << x;cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:s)ost << i << \" \";return ost;}",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, map<U,V> &m){if(&ost == &cerr){cerr <<\"{\";int cnt = m.size();for(auto x:m){cerr << x; cnt--;if(cnt) cerr << \", \";}cerr << \"}\";}else for(auto i:m)ost << i;return ost;}",
            "template <typename U, typename V>istream &operator>>(istream &in, pair<U, V> &p){in>>p.first>>p.second;return in;}",
            "template <typename U, typename V>ostream &operator<<(ostream &ost, pair<U, V> p){if (&ost == &cerr)ost << \"{\" << p.first << \": \" << p.second << \"}\";else ost << p.first << \" \" << p.second << \" \";return ost;}",
            "ostream &operator<<(ostream &ost, __int128_t x){string output = \"\";while(x)output += '0'+x%10, x /= 10;reverse(all(output)); ost << output;  return ost;}",
            "istream &operator>>(istream &in, __int128_t &x){x=0;string num;cin >> num;for(char c:num) x *= 10, x += c-'0';return in;}",
            "//Variadic IO",
            "template <typename... T>void read(T &...args){((cin >> args), ...);}",
            "template <typename... T>void print(T... args){((cout << args << \" \"), ...);cout << endl;}",
            "",
            "template <typename Arg1>",
            "void __f(int line, const char *color, const char* name, Arg1&& arg1){",
            "    cerr << \"\\033[2;37m(Ln \" << line << \")\\033[0m \" << color << name << \": \\033[0;37m\" << arg1 << \"\\033[0m \" << endl;",
            "}",
            "template <typename Arg1, typename... Args>",
            "void __f(int line, const char *color, const char* names, Arg1&& arg1, Args&&... args){",
            "    const char* comma = strchr(names + 1, ',');",
            "    cerr << \"\\033[2;37m(Ln \" << line << \")\\033[0m \" << color;",
            "    cerr.write(names, comma - names) << \": \\033[0;37m\" << arg1 << \"\\033[0m \" << endl;",
            "    __f(line,color, comma+1, args...);",
            "}",
            ""
        ],
        "description": "gen"
    },
    "ahocorasick": {
        "prefix": "ahocorasick",
        "body": [
            "struct Node {",
            "    char ch;",
            "    int endCnt, suffLink, parent;",
            "    map<char,int> next, go;",
            "",
            "    Node(char c, int parent, int suff = 0) {",
            "        ch = c; ",
            "        endCnt = 0;",
            "        suffLink = suff;",
            "        this->parent = parent;",
            "    }",
            "};",
            "",
            "struct AhoCorasick {",
            "    vector<Node> node;",
            "    vector<vector<int>> adj;",
            "    vector<int> count,indices;",
            "    AhoCorasick() {",
            "        node.push_back(Node('$',-1));",
            "        adj.push_back({});",
            "        count.push_back(0);",
            "    }",
            "",
            "    int insert(string s) {",
            "        int curr = 0;",
            "        for(char c:s) {",
            "            if(!node[curr].next.count(c)) {",
            "                node[curr].next[c] = node.size();",
            "                node[curr].go[c] = node.size();",
            "                node.push_back(Node(c,curr));",
            "                adj.push_back({});",
            "                count.push_back(0);",
            "            }",
            "            curr = node[curr].next[c];",
            "            ",
            "        }",
            "        indices.push_back(curr);",
            "        node[curr].endCnt++;",
            "        return curr;",
            "    }",
            "",
            "    void build() {",
            "        queue<int> bfs;",
            "        bfs.push(0);",
            "        while(!bfs.empty()) {",
            "            int vertex = bfs.front();",
            "            bfs.pop();",
            "            for(auto [ch,x]:node[vertex].next) {",
            "                bfs.push(x);",
            "            }",
            "            if(vertex) {",
            "                Node &x = node[vertex];",
            "                int sl = node[x.parent].suffLink;",
            "                while(sl and !node[sl].next.count(x.ch)) sl = node[sl].suffLink;",
            "                sl = node[sl].next.count(x.ch) and node[sl].next[x.ch] != vertex ? node[sl].next[x.ch] : 0;",
            "                x.suffLink = sl;",
            "                adj[sl].push_back(vertex);",
            "            }",
            "        }",
            "    }",
            "",
            "    struct Iterator {",
            "        private:",
            "        AhoCorasick &container;",
            "        public:",
            "        int curr;",
            "        Iterator(AhoCorasick *container): curr(0), container(*container) {} ",
            "",
            "        void go(char c) {",
            "            if(container.node[curr].go.count(c)) curr = container.node[curr].go[c];",
            "            else curr = go(c,curr);",
            "            container.count[curr]++;",
            "        }",
            "",
            "        int go(char c, int curr) {",
            "            if(container.node[curr].go.count(c)) return container.node[curr].go[c];",
            "            if(curr == 0) return curr;",
            "            return container.node[curr].go[c] = go(c,container.node[curr].suffLink);",
            "        }",
            "",
            "        int count() {",
            "            return container.node[curr].endCnt;",
            "        }",
            "    };",
            "",
            "    Iterator begin() {",
            "        return Iterator(this);",
            "    }",
            "",
            "    void run(string s) {",
            "        AhoCorasick::Iterator it = this->begin();",
            "        for(char c:s) it.go(c);",
            "    }",
            "",
            "    vector<int> getCounts() {",
            "        vector<int> cnt = count;",
            "        getCounts(0,cnt);",
            "        vector<int> res;",
            "        for(auto ind:indices) res.push_back(cnt[ind]);",
            "        return res;",
            "    }",
            "    private:",
            "    void getCounts(int curr, vector<int> &count) {",
            "        for(auto child:adj[curr]) {",
            "            getCounts(child,count);",
            "            count[curr] += count[child];",
            "        }",
            "    }",
            "};"
        ],
        "description": "ahocorasick"
    },
    "sgmt": {
        "prefix": "sgmt",
        "body": [
            "template<typename T>",
            "struct Merge {",
            "    T operator()(T &left, T &right) {",
            "        return $1",
            "    }",
            "",
            "    void operator()(T &res, T &left, T &right) {",
            "        res = $1",
            "    }",
            "};",
            "",
            "template<typename T, class __Merge = plus<T>>",
            "struct Segtree {",
            "    int n;",
            "    vector<T> tree;",
            "    __Merge merge;",
            "",
            "    Segtree(int n):n(n),merge(__Merge()) {",
            "        tree.resize(4*n);",
            "        build(0,0,n-1);",
            "    }",
            "    Segtree(vector<int> arr):n(arr.size()),merge(__Merge()) {",
            "        tree.resize(4*n);",
            "        build(arr,0,0,n-1);",
            "    }",
            "",
            "    void build(int ind, int st, int en) {",
            "        if(st == en) {",
            "            tree[ind] = 0;",
            "        } else {",
            "            int mid = (st+en)/2;",
            "            build(2*ind+1,st,mid);",
            "            build(2*ind+2,st,mid);",
            "            tree[ind] = merge(tree[2*ind+1],tree[2*ind+2]);",
            "        }",
            "    }",
            "",
            "    void build(vector<int> &arr, int ind, int st, int en) {",
            "        if(st == en) {",
            "            tree[ind] = arr[st];",
            "        } else {",
            "            int mid = (st+en)/2;",
            "            build(arr,2*ind+1,st,mid);",
            "            build(arr,2*ind+2,mid+1,en);",
            "            tree[ind] = merge(tree[2*ind+1],tree[2*ind+2]);",
            "        }",
            "    }",
            "",
            "    void update(int pos, T val) {",
            "        update(pos,val,0,0,n-1);",
            "    }",
            "",
            "    void update(int pos, T val, int ind, int st, int en) {",
            "        if(pos > en or pos < st) return;",
            "        else if(st==en){",
            "            tree[ind] = val;",
            "        }",
            "        else{",
            "            int mid = (st+en)/2;",
            "            update(pos,val,2*ind+1,st,mid);",
            "            update(pos,val,2*ind+2,mid+1,en);",
            "            tree[ind] = merge(tree[2*ind+1],tree[2*ind+2]);",
            "        }",
            "    }",
            "",
            "    T query(int l, int r) {",
            "        return query(l,r,0,0,n-1);",
            "    }",
            "",
            "    T query(int l, int r, int ind, int st, int en) {",
            "        if(r < st or l > en) return 0;",
            "        else if(r >= en and l <= st) return tree[ind];",
            "        else{",
            "            if(st==en) return tree[ind];",
            "            int mid = (st+en)/2;",
            "            auto a = query(l,r,2*ind+1,st,mid);",
            "            auto b = query(l,r,2*ind+2,mid+1,en);",
            "            auto c = merge(a,b);",
            "            return c;",
            "        }",
            "    }",
            "};",
            "$0"
        ],
        "description": "sgmt"
    },
    "trie": {
        "prefix": "trie",
        "body": [
            "template<typename store_type = map<char,int>>",
            "struct Trie {",
            "    struct Node {",
            "        store_type children;",
            "        char ch;",
            "        int parent, ends;",
            "        Node(char c, int par) {",
            "            ch = c, parent = par, ends = 0;",
            "        }",
            "    };",
            "",
            "    vector<Node> node;",
            "    Trie() {",
            "        node.push_back(Node('$',-1));",
            "    }",
            "    int insert(string s) {",
            "        int ptr = 0;",
            "        for(char c:s) {",
            "            if(!node[ptr].children.count(c)) node[ptr].children[c] = node.size(), node.push_back(Node(c,ptr));",
            "            ptr = node[ptr].children[c];",
            "        }",
            "        node[ptr].ends++;",
            "        return ptr;",
            "    }",
            "    bool remove(string s) {",
            "        int ptr = 0;",
            "        for(char c:s) {",
            "            if(!node[ptr].children.count(c)) return false;",
            "            ptr = node[ptr].children[c];",
            "        }",
            "        if(node[ptr].ends) node[ptr].ends--;",
            "        return true;",
            "    }",
            "    int count(string s) {",
            "        int ptr = 0;",
            "        for(char c:s) {",
            "            if(!node[ptr].children.count(c)) return 0;",
            "            ptr = node[ptr].children[c];",
            "        }",
            "        return node[ptr].ends;",
            "    }",
            "};",
            "",
            "template<>",
            "Trie<vector<int>>::Node::Node(char c, int par) {",
            "    ch = c, parent = par, ends = 0;",
            "    children.assign(26,-1);",
            "}",
            "",
            "template<>",
            "int Trie<vector<int>>::insert(string s) {",
            "    int ptr = 0;",
            "    for(char c:s) {",
            "        c -= 'a';",
            "        if(node[ptr].children[c] == -1) node[ptr].children[c] = node.size(), node.push_back(Node(c,ptr));",
            "        ptr = node[ptr].children[c];",
            "    }",
            "    node[ptr].ends++;",
            "    return ptr;",
            "}",
            "",
            "template<>",
            "bool Trie<vector<int>>::remove(string s) {",
            "    int ptr = 0;",
            "    for(char c:s) {",
            "        c -= 'a';",
            "        if(node[ptr].children[c] == -1) return false;",
            "        ptr = node[ptr].children[c];",
            "    }",
            "    if(node[ptr].ends) node[ptr].ends--;",
            "    return true;",
            "}",
            "",
            "template<>",
            "int Trie<vector<int>>::count(string s) {",
            "    int ptr = 0;",
            "    for(char c:s) {",
            "        c -= 'a';",
            "        if(node[ptr].children[c] == -1) return 0;",
            "        ptr = node[ptr].children[c];",
            "    }",
            "    return node[ptr].ends;",
            "}",
            ""
        ],
        "description": "trie"
    },
    "btrie": {
        "prefix": "btrie",
        "body": [
            "template<bool big = false, bool storeNums = false>",
            "struct BinaryTrie {",
            "    struct Node {",
            "        int children[2] = {};",
            "        Node() {",
            "            children[0] = children[1] = -1;",
            "        }",
            "    };",
            "",
            "    vector<Node> node;",
            "    vector<int> nums;",
            "    BinaryTrie() {",
            "        node.push_back(Node());",
            "    }",
            "",
            "    void insert(int x) {",
            "        int ptr = 0;",
            "        for(int bit = (big ? 59 : 29); bit >= 0; bit--) {",
            "            if(node[ptr].children[(x>>bit)&1] == -1) {",
            "                node[ptr].children[(x>>bit)&1] = node.size();",
            "                node.push_back(Node());",
            "            }",
            "            ptr = node[ptr].children[(x>>bit)&1];",
            "        }",
            "        if(storeNums) nums.push_back(x);",
            "    }",
            "",
            "    int getMax(int x) {",
            "        int ans = 0;",
            "        for(int bit = (big ? 59 : 29); bit >= 0; bit--) {",
            "            if(node[ptr].children[(x>>bit)&1] == -1) {",
            "                ptr = node[ptr].children[1-((x>>bit)&1)];",
            "            } else {",
            "                ptr = node[ptr].children[(x>>bit)&1];",
            "                ans += (1ll<<bit);",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "};",
            ""
        ],
        "description": "btrie"
    },
    "gphashtable": {
        "prefix": "gphashtable",
        "body": [
            "template <typename T, typename = void>",
            "struct is_iterable : std::false_type {};",
            "template <typename T>",
            "struct is_iterable<T, std::void_t<decltype(std::begin(std::declval<T>())),decltype(std::end(std::declval<T>()))>> : std::true_type {};",
            "template <typename T>",
            "constexpr bool is_iterable_v = is_iterable<T>::value;",
            "",
            "const int RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "struct cHash {",
            "    int operator()(int x) const {",
            "        return x^RANDOM;",
            "    }",
            "    int operator()(long long x) const {",
            "        return ((((x>>32)^((80458053ll*RANDOM)%1343867543))<<32) + ((x%(1ll<<32))^RANDOM))%686823435;",
            "    }",
            "    int operator()(pair<int,int> p) const {",
            "        int RANDOM2 = (80458053ll*RANDOM)%1343867543;",
            "        return (1ll*(p.first^RANDOM)*(p.second^RANDOM2))%1538432894;",
            "    }",
            "    template<typename T, enable_if_t<is_iterable_v<T>,bool> = true>",
            "    int operator()(T container) const {",
            "        long long __hash = 0;",
            "        long long __seed = RANDOM;",
            "        for(auto it = begin(container); it != end(container); ++it) {",
            "            (__hash += (cHash()(*it)^__seed)) %= 1009495349;",
            "            __seed = (__seed*__seed)%340858240;",
            "        }",
            "        return __hash;",
            "    }",
            "};",
            "",
            "template<typename __key_type, typename __value_type>",
            "using UnorderedMap = __gnu_pbds::gp_hash_table<__key_type,__value_type,cHash>;",
            "",
            "template<typename __key_type>",
            "using UnorderedSet = __gnu_pbds::gp_hash_table<__key_type,null_type,cHash>;",
            ""
        ],
        "description": "gphashtable"
    },
    "fraction": {
        "prefix": "fraction",
        "body": [
            "struct Fraction {",
            "    long long numerator, denominator;",
            "    Fraction(int n, int d) {",
            "        int GCD = __gcd(abs(n),abs(d));",
            "        n /= GCD, d /= GCD;",
            "        numerator = n, denominator = d;",
            "    }",
            "    Fraction(int i) {",
            "        this->denominator = 1, this->numerator = i;",
            "    }",
            "    Fraction() {",
            "        numerator = 0, denominator = 1;",
            "    }",
            "    Fraction operator+(Fraction f){",
            "        return Fraction(this->numerator*f.denominator+f.numerator*this->denominator,this->denominator * f.denominator);",
            "    }",
            "    Fraction operator-(Fraction f){",
            "        return Fraction(this->numerator*f.denominator-f.numerator*this->denominator,this->denominator * f.denominator);",
            "    }",
            "    Fraction operator*(Fraction f) {",
            "        return Fraction(this->numerator*f.numerator, this->denominator*f.denominator);",
            "    }",
            "    bool operator==(Fraction f) {",
            "        return this->numerator==f.numerator and this->denominator==f.denominator;",
            "    }",
            "};",
            "bool operator<(Fraction a, Fraction f) {",
            "    return a.numerator*f.denominator < f.numerator*a.denominator;",
            "}",
            "ostream &operator<<(ostream &ost, Fraction f) {",
            "    ost << f.numerator << \"/\" << f.denominator;",
            "    return ost;",
            "}"
        ],
        "description": "fraction"
    },
    "treap": {
        "prefix": "treap",
        "body": [
            "struct TreapNode {",
            "    int data, subsize, priority;",
            "    TreapNode *left, *right;",
            "    TreapNode(int data) {",
            "        this->data = data;",
            "        this->subsize = 1;",
            "        this->priority = abs((int)(rng()));",
            "        this->left = this->right = nullptr;",
            "    }",
            "};",
            " ",
            "TreapNode *merge(TreapNode *left, TreapNode *right) {",
            "    if (left == nullptr) return right;",
            "    if (right == nullptr) return left;",
            "    if (left->priority < right->priority) {",
            "        left->right = merge(left->right, right);",
            "        left->subsize = 1;",
            "        if(left->left) left->subsize += left->left->subsize;",
            "        if(left->right) left->subsize += left->right->subsize;",
            "        return left;",
            "    } else {",
            "        right->left = merge(left, right->left);",
            "        right->subsize = 1;",
            "        if(right->left) right->subsize += right->left->subsize;",
            "        if(right->right) right->subsize += right->right->subsize;",
            "        return right;",
            "    }",
            "}",
            "",
            "pair<TreapNode*, TreapNode*> split(TreapNode *root, int k) {",
            "    if (root == nullptr) return {nullptr, nullptr};",
            "    if (k == 0) return {nullptr, root};",
            "    if(root->left and root->left->subsize >= k) {",
            "        auto [left, right] = split(root->left, k);",
            "        root->left = right;",
            "        root->subsize = 1;",
            "        if(root->left) root->subsize += root->left->subsize;",
            "        if(root->right) root->subsize += root->right->subsize;",
            "        return {left, root};",
            "    } else {",
            "        auto [left, right] = split(root->right, k - (root->left ? root->left->subsize : 0) - 1);",
            "        root->right = left;",
            "        root->subsize = 1;",
            "        if(root->left) root->subsize += root->left->subsize;",
            "        if(root->right) root->subsize += root->right->subsize;",
            "        return {root, right};",
            "    }",
            "}"
        ],
        "description": "treap"
    },
    "ilist": {
        "prefix": "ilist",
        "body": [
            "template<typename T>",
            "struct iListNode {",
            "    T value, data;",
            "    int size, priority;",
            "    iListNode *left, *right;",
            "    iListNode(T value) {",
            "        this->value = data = value;",
            "        left = right = nullptr;",
            "        size = 1;",
            "        priority = abs((int)(rng()));",
            "    }",
            "    void recalc() {",
            "        size = 1;",
            "        data = value;",
            "        if(left) {",
            "            size += left->size;",
            "            data = left->data+data;",
            "        } ",
            "        if(right) {",
            "            size += right->size;",
            "            data = data+right->data;",
            "        }",
            "    }",
            "    void update(T newValue) {",
            "        value = newValue;",
            "        recalc();",
            "    }",
            "    ~iListNode() {",
            "        if(left) {",
            "            delete left;",
            "            left = nullptr;",
            "        }",
            "        if(right) {",
            "            delete right;",
            "            right = nullptr;",
            "        }",
            "    }",
            "};",
            "",
            "template<typename T>",
            "struct iList {",
            "    static iListNode<T> *__merge(iListNode<T> *left, iListNode<T> *right) {",
            "        if(not left) return right;",
            "        if(not right) return left;",
            "        if(left->priority < right->priority) {",
            "            left->right = __merge(left->right,right);",
            "            left->recalc();",
            "            return left;",
            "        } else {",
            "            right->left = __merge(left,right->left);",
            "            right->recalc();",
            "            return right;",
            "        }",
            "    }",
            "",
            "    static pair<iListNode<T> *,iListNode<T> *> __split(iListNode<T> *root, int k) {",
            "        if(k == 0) return {nullptr,root};",
            "        assert(k >= 0 and root->size >= k);",
            "        if(root->left and k <= root->left->size) {",
            "            auto[left,right] = __split(root->left,k);",
            "            root->left = right;",
            "            root->recalc();",
            "            return {left,root};",
            "        } else {",
            "            auto[left,right] = __split(root->right,k-1-(root->left?root->left->size:0));",
            "            root->right = left;",
            "            root->recalc();",
            "            return {root,right};",
            "        }",
            "    }",
            "",
            "    static T &__get(iListNode<T> *root, int k) {",
            "        int leftSize = root->left?root->left->size:0;",
            "        if(k == leftSize) return root->value;",
            "        if(k < leftSize) return __get(root->left,k);",
            "        return __get(root->right,k-leftSize-1);",
            "    }",
            "",
            "    static iListNode<T> *__copy(iListNode<T> *root) {",
            "        if(not root) return nullptr;",
            "        iListNode<T> *newRoot = new iListNode<T>(root->value);",
            "        newRoot->left = __copy(root->left);",
            "        newRoot->right = __copy(root->right);",
            "        newRoot->recalc();",
            "        return newRoot;",
            "    }",
            "",
            "    static void __dfs(iListNode<T> *root, vector<T> &v) {",
            "        if(not root) return;",
            "        __dfs(root->left,v);",
            "        v.push_back(root->value);",
            "        __dfs(root->right,v);",
            "    }",
            "",
            "    iListNode<T> *root;",
            "    iList() {",
            "        root = nullptr;",
            "    }",
            "    iList(initializer_list<T> v) {",
            "        root = nullptr;",
            "        for(auto i:v) {",
            "            root = __merge(root,new iListNode<T>(i));",
            "        }",
            "    }",
            "    iList(vector<T> v) {",
            "        root = nullptr;",
            "        for(auto i:v) {",
            "            root = __merge(root,new iListNode<T>(i));",
            "        }",
            "    }",
            "    iList(T arr[], int n) {",
            "        root = nullptr;",
            "        for(int i=0;i<n;i++) {",
            "            root = __merge(root,new iListNode<T>(arr[i]));",
            "        }",
            "    }",
            "    iList(int n, T element) {",
            "        root = nullptr;",
            "        for(int i=0;i<n;i++) {",
            "            root = __merge(root,new iListNode<T>(element));",
            "        }",
            "    }",
            "    void assign(int n, T element) {",
            "        clear();",
            "        for(int i=0;i<n;i++) {",
            "            root = __merge(root,new iListNode<T>(element));",
            "        }",
            "    }",
            "    // Doesn't return a reference, to edit values see update function",
            "    T operator[](int index) {",
            "        assert(index >= 0 and root and root->size > index);",
            "        return __get(root,index);",
            "    }",
            "    void clear() {",
            "        delete root;",
            "        root = nullptr;",
            "    }",
            "    bool empty() {",
            "        return not root;",
            "    }",
            "    int size() {",
            "        return empty() ? 0 : root->size;",
            "    }",
            "    void push_back(T value) {",
            "        auto node = new iListNode(value);",
            "        root = __merge(root,node);",
            "    }",
            "",
            "    // copies the list by value",
            "    iList operator=(iList list) {",
            "        clear();",
            "        root = __copy(list.root);",
            "    }",
            "",
            "    // inserts another list at the given position",
            "    void insert(int position, iList<T> list) {",
            "        assert(position >= 0 and position < size());",
            "        auto middle = __copy(list.root);",
            "        auto[left,right] = __split(root,position);",
            "        root = __merge(left,middle);",
            "        root = __merge(root, right);",
            "    }",
            "",
            "    //removes size elements starting from index ",
            "    void erase(int index, int size) {",
            "        assert(index >= 0 and size > 0 and index+size <= this->size());",
            "        auto[left,R] = __split(root,index);",
            "        auto[discarded,right] = __split(R,size);",
            "        delete discarded;",
            "        root = __merge(left,right);",
            "    }",
            "    // splits off the last k elements of the list into newList",
            "    // deletes the contents already in newList",
            "    void split(iList<T> &newList, int k) {",
            "        assert(k <= size());",
            "        auto[left,right] = __split(root,size()-k);",
            "        newList.clear();",
            "        newList.root = right;",
            "        root = left;",
            "    }",
            "",
            "    //return sum(or whatever you code it to return) of elements between positions l and r (inclusive)",
            "    T query(int l, int r) {",
            "        assert(r >= l and l >= 0 and r < size());",
            "        int querySize = r-l+1;",
            "        auto[left,temp] = __split(root,l);",
            "        auto[qry,right] = __split(temp,querySize);",
            "        T answer = qry->data;",
            "        root = __merge(left,__merge(qry,right));",
            "        return answer;",
            "    }",
            "",
            "    //update element at index with newValue",
            "    void update(int index, T newValue) {",
            "        assert(index >= 0 and index < size());",
            "        auto[left,temp] = __split(root,index);",
            "        auto[qry,right] = __split(temp,1);",
            "        qry->update(newValue);",
            "        root = __merge(left,__merge(qry,right));",
            "    }",
            "",
            "    vector<T> elements() {",
            "        vector<T> res;",
            "        __dfs(root,res);",
            "        return res;",
            "    }",
            "",
            "    ~iList() {",
            "        clear();",
            "    }",
            "",
            "};",
            "",
            "template<typename T>",
            "ostream &operator<<(ostream &ost, iListNode<T> *root) {",
            "    if(not root) return ost;",
            "    return ost << root->left << root->value << \" \" << root->right;",
            "}",
            "",
            "template<typename T>",
            "ostream &operator<<(ostream &ost, iList<T> &list) {",
            "    return ost << list.root;",
            "}"
        ],
        "description": "ilist"
    }
}
